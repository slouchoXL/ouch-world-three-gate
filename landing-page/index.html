<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
      <title>LandingPage</title>
      <meta name="viewport"
            content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
            <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
            <script>
              // Safe to expose in client
              window.__SUPABASE_URL = 'https://srdwkfjterotzjwzoauj.supabase.co';
              window.__SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNyZHdrZmp0ZXJvdHpqd3pvYXVqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU4NjU5NTksImV4cCI6MjA3MTQ0MTk1OX0.c0mJbQsfJMmqLiulXdZfWscd7J507buzRXkd700ymAQ';
            </script>
            <script>
              window.supa = window.supabase.createClient(
                window.__SUPABASE_URL,
                window.__SUPABASE_ANON_KEY
              );
            </script>
            <script>
            (async function () {
              try {
                if (window.supa && location.hash && location.hash.includes('access_token')) {
                  const params = new URLSearchParams(location.hash.slice(1));
                  const access_token = params.get('access_token');
                  const refresh_token = params.get('refresh_token');
                  const error = params.get('error');
                  const error_description = params.get('error_description');

                  if (error) {
                    alert(`Authentication error: ${error_description || error}`);
                    history.replaceState({}, '', location.pathname + location.search);
                    return;
                  }
                  if (access_token && refresh_token) {
                    const { error } = await window.supa.auth.setSession({ access_token, refresh_token });
                    if (error) alert(`Session error: ${error.message}`); else window.location.reload();
                  }
                  history.replaceState({}, '', location.pathname + location.search);
                }
              } catch (e) { console.error('[supabase] Magic link processing failed:', e); }
            })();
            </script>

  <title>landing-page</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
        height: 100%;
        overflow: hidden;
        font-family: Arial, sans-serif;
        background: #000; color: #fff;
        touch-action: none;
        -ms-touch-action: none;
        
    }
      
      
    .container { width: 100vw; height: 100vh; position: relative; }
    #scene-container { position: absolute; inset: 0; z-index: 1; }
    #scene-container canvas { display: block; cursor: pointer; }

    /* Top navigation */
    .top-nav {
      position: fixed; top: 0; left: 0; right: 0; z-index: 100;
      display: flex; justify-content: space-between; align-items: center; padding: 20px;
    }
    .menu-button, .login-button {
      width: 30px; height: 30px;
      background: #000;
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 50%;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      backdrop-filter: none;
      transition: border-color .2s ease, background .2s ease;
    }
    .menu-button:hover, .login-button:hover {
      border-color: rgba(255, 255, 255, 0.45);
      background: #000;
    }
    .menu-dots { display: flex; gap: 4px; }
    .dot { width: 3px; height: 3px; background: #fff; border-radius: 50%; }
    .user-icon { width: 16px; height: 16px; color: #fff; }
    .user-icon svg { width: 100%; height: 100%; fill: currentColor; }

    /* Menu tray */
    .menu-tray {
      position: fixed; top: 60px; left: 20px; width: 130px;
      background: rgba(0, 0, 0, 1); backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; z-index: 200;
      transform: translateY(-20px); opacity: 0; visibility: hidden; transition: all .3s ease; padding: 10px 0;
    }
    .menu-tray.open { transform: translateY(0); opacity: 1; visibility: visible; }

    /* Menu items with pill hover */
    .menu-item {
      position: relative;
      display: block;
      width: 100%;
      padding: 6px 15px;
      color: #fff;
      text-decoration: none;
      font-size: 14px;
      font-weight: 300;
      cursor: pointer;
      background: none;
      border: 0;
    }

    .menu-item::before {
      content: "";
      position: absolute;
      inset: 1px;
      left: 8px;
      right: 8px;
      border-radius: 8px;
      background: rgba(255,255,255,0.12);
      opacity: 0;
      transform: scaleY(0.96);
      transition: opacity .15s ease, transform .2s ease;
      pointer-events: none;
    }

    .menu-item:hover::before,
    .menu-item:focus-visible::before {
      opacity: 1;
      transform: scaleY(1);
    }

    .menu-item, .menu-item * {
      position: relative;
      z-index: 1;
    }

    .menu-item .menu-pill {
      background: transparent !important;
      padding: 0 !important;
      border-radius: 0 !important;
    }

    /* Modal overlay + dialog */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      z-index: 300;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(5px);
    }
    .modal-overlay.show {
      display: flex;
    }
    .login-modal {
      background: rgba(0,0,0,0.9);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 16px;
      padding: 15px;
      width: 90%;
      max-width: 400px;
      position: relative;
      color: #fff;
    }
    .modal-close {
      position: absolute;
      top: 8px; right: 15px;
      background: none; border: none;
      color: rgba(255,255,255,0.6);
      font-size: 24px; cursor: pointer;
      width: 30px; height: 30px; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      transition: all .2s ease;
    }
      input, textarea, select {
           font-size: 16px;
         }
      /* Tell browsers these elements trigger only taps/clicks (no zooming gestures) */
      button, a, .menu-button, .login-button, .chat-toggle, .send-button, .arrow-btn, .character-confirm {
        touch-action: manipulation;
      }

    .modal-close:hover { color: #fff; background: none; }
    .modal-title { font-size: 24px; font-weight: 300; margin-bottom: 20px; text-align: center; }
    .modal-tabs { display: flex; gap: 20px; margin-bottom: 20px; justify-content: center; }
    .modal-tab { background: none; border: none; color: rgba(255,255,255,0.6); font-size: 16px; padding: 8px 0; cursor: pointer; border-bottom: 2px solid transparent; transition: all .2s ease; }
    .modal-tab.active { color: #fff; }
    .form-group { margin-bottom: 12px; }
    .form-input {
      width: 100%; background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2); border-radius: 8px;
      padding: 12px 15px; color: #fff; font-size: 16px; outline: none;
    }
    .form-input::placeholder { color: rgba(255,255,255,0.5); }
    .form-button {
      width: 100%; background: rgba(255,255,255,0.92); color: #000;
      border: none; border-radius: 8px; padding: 12px; font-size: 14px; font-weight: 500; cursor: pointer;
    }

    /* Chat popup */
    .chatbot-container {
      position: fixed;
      left: 50%;
      transform: translateX(-50%) translateY(8px);
      bottom: calc(var(--chat-toggle-bottom) + var(--chat-toggle-size) + var(--chat-gap));
      z-index: 50;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transition: opacity .25s ease, transform .25s ease, visibility 0s linear .25s;
      width: 300px;
      min-width: 300px;
      max-width: 300px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }

    .chatbot-container.open {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
      visibility: visible;
      pointer-events: auto;
      transition: opacity .25s ease, transform .25s ease;
    }

    :root {
      --msg-font-size: 11px;
      --msg-line-h: 1.3;
      --msg-vpad: 6px;
      --msg-gap: 6px;
    }

    .chat-messages {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: var(--msg-gap);
      height: 72px;
      overflow-y: auto;
      padding-right: 5px;
      margin-bottom: 10px;
    }

    .message {
      display: inline-block;
      width: auto;
      max-width: 85%;
      font-size: var(--msg-font-size);
      line-height: var(--msg-line-h);
      padding: var(--msg-vpad) 10px;
      overflow-wrap: anywhere;
      background: rgba(255,255,255,0.1);
      border-radius: 8px;
      margin-bottom: 6px;
      word-wrap: break-word;
    }
    .message.user { align-self: flex-end; text-align: left; background: rgba(255,255,255,0.2); }
    .message.bot { background: rgba(100,100,100,0.3); }

    .chat-messages::-webkit-scrollbar { width: 4px; }
    .chat-messages::-webkit-scrollbar-track { background: rgba(255,255,255,0.1); border-radius: 2px; }
    .chat-messages::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 2px; }
    .chat-input-container {
      display: flex; align-items: center; gap: 8px; background: rgba(255,255,255,0.1);
      border-radius: 8px; padding: 8px 12px; border: 1px solid rgba(255,255,255,0.1);
    }
    .chat-input { flex: 1; background: none; border: none; outline: none; color: #fff; font-size: 16px; }
    .chat-input::placeholder { color: rgba(255,255,255,0.6); }
    .send-button { background: none; border: none; color: rgba(255,255,255,0.8); cursor: pointer; padding: 4px; border-radius: 4px; transition: color .2s ease; display: flex; align-items: center; justify-content: center; }
    .send-button:hover { color: #fff; }
    .send-button svg { width: 14px; height: 14px; }

    /* Chat toggle button */
    :root {
      --chat-toggle-size: 30px;
      --chat-toggle-bottom: 16px;
      --chat-gap: 14px;
    }

    .chat-toggle {
      position: fixed;
      bottom: var(--chat-toggle-bottom);
      left: 50%;
      transform: translateX(-50%);
      z-index: 60;
      width: var(--chat-toggle-size);
      height: var(--chat-toggle-size);
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.25);
      background: #000;
      color: white;
      font-size: 12px;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer;
      transition: border-color .2s ease, background .2s ease;
    }

    .chat-toggle:hover { border-color: rgba(255,255,255,0.45); }

    /* Character selector */
    :root {
      --title-width: 240px;
      --arrow-gap: 6px;
      --arrow-size-w: 34px;
      --arrow-size-h: 30px;
      --modal-padding-x: 10px;
    }
    .character-controls { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; display: none; }
    .character-controls.show { display: block; }
    .character-info {
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      padding: 8px var(--modal-padding-x);
      width: calc(var(--title-width) + 2 * (var(--arrow-size-w) + var(--arrow-gap)) + 2 * var(--modal-padding-x));
    }
    .character-header {
      display: grid;
      grid-template-columns: var(--arrow-size-w) var(--title-width) var(--arrow-size-w);
      align-items: center; justify-items: center; column-gap: var(--arrow-gap);
    }
    .character-name { font-size: 14px; font-weight: 600; text-align: center; white-space: nowrap; width: var(--title-width); overflow: hidden; text-overflow: ellipsis; line-height: 1; }
    .arrow-btn {
      width: var(--arrow-size-w); height: var(--arrow-size-h);
      border: none; background: none; color: #fff; cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      font-size: 16px; line-height: 1; transition: opacity .2s ease;
    }
    .arrow-btn:hover { opacity: 0.8; }
    .character-actions { display: flex; justify-content: center; margin-top: 8px; }
    .character-confirm { background: rgba(255,255,255,0.92); color: #000; border: none; border-radius: 8px; padding: 6px 12px; font-size: 12px; cursor: pointer; transition: background .2s ease; }
    .character-confirm:hover { background: #fff; }

    @media (max-width: 420px) {
      :root { --arrow-size-w: 30px; --arrow-size-h: 28px; --modal-padding-x: 8px; }
    }

    @media (prefers-reduced-motion: reduce) {
      .chatbot-container { transition: none; transform: translateX(-50%); }
      .chatbot-container.open { transition: none; }
    }
  </style>
</head>
<body>

<div class="container">
  <div id="scene-container"></div>

  <!-- Top Navigation -->
  <div class="top-nav">
    <button class="menu-button" onclick="toggleMenu()">
      <div class="menu-dots"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
    </button>
    <button class="login-button" onclick="handleLogin()">
      <div class="user-icon">
        <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
      </div>
    </button>
  </div>

  <!-- Menu Tray -->
  <div class="menu-tray" id="menuTray">
    <a href="/landing-page/" class="menu-item"><span class="menu-pill">Home</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Label</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Merch</span></a>
    <a href="/packs/" class="menu-item"><span class="menu-pill">Packs</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Inventory</span></a>
  </div>

  <!-- Character Selector -->
  <div class="character-controls" id="characterControls">
    <div class="character-info">
      <div class="character-header">
        <button class="arrow-btn" id="prevArrow" title="Previous">‹</button>
        <div class="character-name" id="characterName">Default Character</div>
        <button class="arrow-btn" id="nextArrow" title="Next">›</button>
      </div>
      <div class="character-actions">
        <button class="character-confirm" onclick="window.confirmCharacter()">Select</button>
      </div>
    </div>
  </div>

  <!-- Login Modal -->
  <div class="modal-overlay" id="loginModal">
    <div class="login-modal">
      <button class="modal-close" onclick="closeLoginModal()">&times;</button>
      <div class="modal-tabs">
        <button class="modal-tab active" onclick="switchTab('login')">Account</button>
      </div>
      <div id="loginForm">
        <div class="form-group">
          <input type="email" id="loginEmail" class="form-input" placeholder="Email" required>
        </div>
        <button id="loginSubmit" class="form-button">Create / Login</button>
      </div>

      <div id="signupForm" style="display:none;">
        <div class="form-group"><input type="text" class="form-input" placeholder="Username"></div>
        <div class="form-group"><input type="email" class="form-input" placeholder="Email"></div>
        <button class="form-button">Sign Up</button>
      </div>
    </div>
  </div>

  <!-- Chatbot -->
  <div class="chatbot-container">
    <div class="chat-messages" id="chatMessages"><div class="message bot">Hi there, how can I help?</div></div>
    <div class="chat-input-container">
      <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." onkeypress="handleKeyPress(event)"/>
      <button class="send-button" onclick="sendMessage()">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
      </button>
    </div>
  </div>

  <!-- Chat toggle button -->
  <button class="chat-toggle" id="chatToggle" aria-label="Toggle chat">💱</button>
</div>

<script>
    // Globals
    let scene, camera, renderer;
    let raycaster, mouseNDC;
    let hoverActive = false;
    let lastHoverState = false;
    let hoverLight = null;
    let gltfLoader, dracoLoader;
    let currentModel = null;     // store the active GLB's root
    let currentMixer = null;    
    const clock = new THREE.Clock();// (optional) for animations

    // ===== Character Data =====
    window.scene = null;
    window.camera = null;
    window.renderer = null;
    window.character = null;
    window.currentCharacterIndex = 0;
    
    function initLoaders() {
      gltfLoader = new THREE.GLTFLoader();

      // If your GLBs are DRACO-compressed, enable this:
      dracoLoader = new THREE.DRACOLoader();
      // Use Google's CDN (works fine for prod); or host your own decoders
      dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
      gltfLoader.setDRACOLoader(dracoLoader);
    }

    window.characterConfigs = [
      { name: "Sloucho", status: "Unlocked", url: "/assets/models/sloucho.glb", scale: 1.0, y: 0 },
      { name: "Ras",     status: "Unlocked", url: "/assets/models/ras.glb",     scale: 1.0, y: 0 },
      { name: "Super Maramu 2000",  status: "Locked",   url: "/assets/models/maramu.glb",  scale: 1.0, y: 0 }
    ];

    // ===== Character UI Logic =====
    window.updateCharacterInfo = function() {
        const config = window.characterConfigs[window.currentCharacterIndex];
        const nameEl = document.getElementById('characterName');
        const confirmBtn = document.querySelector('.character-confirm');
        if (!config || !nameEl) return;
        nameEl.textContent = config.name;

        if (confirmBtn) {
            const locked = config.status === 'Locked';
            confirmBtn.disabled = locked;
            confirmBtn.style.opacity = locked ? '0.5' : '1';
            confirmBtn.textContent = locked ? 'Locked' : 'Select';
        }
    };

    window.previousCharacter = function() {
        window.currentCharacterIndex = (window.currentCharacterIndex - 1 + window.characterConfigs.length) % window.characterConfigs.length;
        if (typeof window.createCharacter === 'function') window.createCharacter();
        window.updateCharacterInfo();
    };
    window.nextCharacter = function() {
        window.currentCharacterIndex = (window.currentCharacterIndex + 1) % window.characterConfigs.length;
        if (typeof window.createCharacter === 'function') window.createCharacter();
        window.updateCharacterInfo();
    };
    window.confirmCharacter = function() {
        const config = window.characterConfigs[window.currentCharacterIndex];
        if (config && config.status === 'Unlocked') window.hideCharacterControls();
    };
    window.hideCharacterControls = function() {
        document.getElementById('characterControls')?.classList.remove('show');
        lastHoverState = null;
    };
    window.onCharacterClick = function() {
        const controls = document.getElementById('characterControls');
        if (controls) {
            controls.classList.add('show');
            window.updateCharacterInfo();
        }
    };
    
    

    // ===== Character Factory =====
    window.createCharacter = function () {
      if (!window.scene || !gltfLoader) {
        console.error('Loaders/scene not ready');
        return;
      }

      // 1) Stop any previous animations and dispose previous model
      if (currentMixer) {
        try { currentMixer.stopAllAction(); } catch (_) {}
        if (currentModel) {
          try { currentMixer.uncacheRoot(currentModel); } catch (_) {}
        }
        currentMixer = null;
      }
      if (currentModel) {
        window.scene.remove(currentModel);
        disposeObject(currentModel);
        currentModel = null;
      }

      // 2) Resolve the config for the currently selected character
      const cfgList = window.characterConfigs || [];
      const idx = (window.currentCharacterIndex ?? 0) % (cfgList.length || 1);
      const cfg = cfgList[idx];
      if (!cfg || !cfg.url) return;

      // 3) Load the GLB and set it up
      gltfLoader.load(
        cfg.url,
        (gltf) => {
          const root = gltf.scene || (gltf.scenes && gltf.scenes[0]);
          if (!root) return;

          // Placement & scale
          root.position.set(0, cfg.y ?? 0, 0);
          const s = cfg.scale ?? 1;
          root.scale.setScalar ? root.scale.setScalar(s) : root.scale.set(s, s, s);

          // Mesh flags (optional)
          root.traverse((obj) => {
            if (obj.isMesh) {
              obj.castShadow = true;
              obj.receiveShadow = true;
              // If you have transparency issues, you can also do:
              // obj.frustumCulled = false;
            }
          });

          // 4) Animations (play "Idle" if available, else first clip)
          if (gltf.animations && gltf.animations.length) {
            currentMixer = new THREE.AnimationMixer(root);
            const idleClip =
              THREE.AnimationClip.findByName(gltf.animations, 'Idle') ||
              gltf.animations[0];

            const action = currentMixer.clipAction(idleClip);
            action.reset().fadeIn(0.2).play();
          } else {
            currentMixer = null;
          }

          // 5) Add to scene and remember it
          window.scene.add(root);
          currentModel = root;
          window.character = root;

          // 6) Update your UI label/etc.
          window.updateCharacterInfo?.();
        },
        undefined,
        (err) => console.error('GLB load error:', err)
      );
    };

    // Helper to free GPU memory when swapping models
    function disposeObject(obj) {
      obj.traverse((node) => {
        if (node.isMesh) {
          node.geometry?.dispose?.();
          if (node.material) {
            if (Array.isArray(node.material)) node.material.forEach(m => m.map?.dispose?.());
            else node.material.map?.dispose?.();
            if (Array.isArray(node.material)) node.material.forEach(m => m.dispose?.());
            else node.material.dispose?.();
          }
        }
      });
    }
    

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.033); // ~30fps clamp to avoid big jumps
      if (currentMixer) currentMixer.update(dt);
      renderer.render(scene, camera);
    }



    // ===== Three.js Setup =====
    function initThreeJS() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        window.scene = scene;

        // Camera
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 5);
        window.camera = camera;

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('scene-container').appendChild(renderer.domElement);
        window.renderer = renderer;

        // Lights
        scene.add(new THREE.AmbientLight(0x404040, 0.6));
        const dir = new THREE.DirectionalLight(0xffffff, 0.8);
        dir.position.set(10,10,5);
        dir.castShadow = true;
        scene.add(dir);
        const rim = new THREE.DirectionalLight(0x4444ff, 0.3);
        rim.position.set(-5,0,-5);
        scene.add(rim);

        // Character
        if (typeof window.createCharacter === 'function') window.createCharacter();

        // Raycaster for hover highlight
        raycaster = new THREE.Raycaster();
        mouseNDC = new THREE.Vector2();

        // Events
        renderer.domElement.addEventListener('click', onCanvasClick);
        window.addEventListener('resize', onWindowResize);
        window.addEventListener('mousemove', onMouseMove);

        // Lock modal width
        setFixedTitleWidth("Super Maramu 2000");

        animate();
    }

    function onCanvasClick(e) {
        if (!window.character || !camera || !renderer) return;

        const rect = renderer.domElement.getBoundingClientRect();
        const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
        const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

        if (!raycaster) raycaster = new THREE.Raycaster();
        raycaster.setFromCamera({ x, y }, camera);

        const hits = raycaster.intersectObjects(window.character.children, true);
        if (hits.length > 0) {
            window.onCharacterClick();
        }
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseMove(e) {
        mouseNDC.x =  (e.clientX / window.innerWidth)  * 2 - 1;
        mouseNDC.y = -(e.clientY / window.innerHeight) * 2 + 1;
        checkHover();
    }

    function selectorOpen() {
        return !!document.getElementById('characterControls')?.classList.contains('show');
    }

    function checkHover() {
        if (!window.character) return;

        if (selectorOpen()) {
            if (lastHoverState) {
                setCharacterHighlight(false);
                lastHoverState = false;
            }
            return;
        }

        raycaster.setFromCamera(mouseNDC, camera);
        const intersects = raycaster.intersectObjects(window.character.children, true);
        hoverActive = intersects.length > 0;

        if (hoverActive !== lastHoverState) {
            setCharacterHighlight(hoverActive);
            lastHoverState = hoverActive;
        }
    }

    function setCharacterHighlight(active) {
        if (!window.scene || !window.character) return;

        if (active) {
            if (!hoverLight) {
                hoverLight = new THREE.PointLight(0x88aaff, 0.35, 3, 2);
                hoverLight.castShadow = false;
                hoverLight.position.set(0, 1.2, 1.6);
                window.character.add(hoverLight);
            }
        } else {
            if (hoverLight) {
                hoverLight.parent?.remove(hoverLight);
                hoverLight = null;
            }
            window.character.traverse(obj => {
                if (obj.isMesh && obj.material && 'emissive' in obj.material) {
                    obj.material.emissive.setHex(0x000000);
                }
            });
        }
    }


    function setFixedTitleWidth(ghostString) {
        const nameEl = document.getElementById('characterName');
        if (!nameEl) return;

        const measurer = document.createElement('span');
        measurer.style.position = 'absolute';
        measurer.style.visibility = 'hidden';
        measurer.style.whiteSpace = 'nowrap';
        measurer.style.fontFamily = getComputedStyle(nameEl).fontFamily;
        measurer.style.fontSize = getComputedStyle(nameEl).fontSize;
        measurer.style.fontWeight = getComputedStyle(nameEl).fontWeight;
        measurer.textContent = ghostString;
        document.body.appendChild(measurer);

        const width = Math.ceil(measurer.getBoundingClientRect().width);
        document.body.removeChild(measurer);

        document.documentElement.style.setProperty('--title-width', width + 'px');

        const info = document.querySelector('.character-info');
        if (info) {
            const _ = getComputedStyle(info).width;
        }
    }

    // ===== UI: Menu & Login =====
    function toggleMenu() {
        document.getElementById('menuTray').classList.toggle('open');
    }
    function handleLogin() {
        document.getElementById('loginModal').classList.add('show');
    }
    function closeLoginModal() {
        document.getElementById('loginModal').classList.remove('show');
    }
    function switchTab(tab) {
        const tabs = document.querySelectorAll('.modal-tab');
        const loginForm = document.getElementById('loginForm');
        const signupForm = document.getElementById('signupForm');
        tabs.forEach(t => t.classList.remove('active'));
        if (tab === 'login') {
            tabs[0].classList.add('active');
            loginForm.style.display = 'block';
            signupForm.style.display = 'none';
        } else {
            tabs[1].classList.add('active');
            loginForm.style.display = 'none';
            signupForm.style.display = 'block';
        }
    }

    // Close menu when clicking outside
    document.addEventListener('click', function(e) {
        const tray = document.getElementById('menuTray');
        const btn = document.querySelector('.menu-button');
        if (tray && !tray.contains(e.target) && !btn.contains(e.target)) {
            tray.classList.remove('open');
        }
    });

    // Close modal when clicking outside
    document.getElementById('loginModal').addEventListener('click', function(e) {
        if (e.target === this) closeLoginModal();
    });

    // Chatbot functions
    function handleKeyPress(e) {
        if (e.key === 'Enter') sendMessage();
    }
    
    function sendMessage() {
        const input = document.getElementById('chatInput');
        const text = input.value.trim();
        if (!text) return;
        addMessage(text, 'user');
        input.value = '';
        setTimeout(() => addMessage(generateBotResponse(text), 'bot'), 500);
    }
    
    function addMessage(text, sender) {
        const box = document.getElementById('chatMessages');
        if (!box) return;
        const div = document.createElement('div');
        div.className = `message ${sender}`;
        div.textContent = text;
        box.appendChild(div);
        box.scrollTop = box.scrollHeight;
    }
    
    function generateBotResponse(msg) {
        const m = msg.toLowerCase();
        if (m.includes('hello')) return "Hello! Welcome to the character showcase. How can I help you today?";
        if (m.includes('hi')) return "Hi there! I'm here to help you navigate the site. What would you like to know?";
        if (m.includes('help')) return "I can help you with information about the character, navigation, or features of this site.";
        if (m.includes('character')) return "This is a 3D character model you can click to open the selector.";
        if (m.includes('website')) return "This website showcases 3D character models with interactive features.";
        if (m.includes('menu')) return "Click the three dots in the top-left to open the menu.";
        if (m.includes('login')) return "Click the user icon in the top-right to open login.";
        return "Thanks for your message! Ask about the character, website features, or navigation.";
    }

    // Chat toggle functionality
    const chatEl = document.querySelector('.chatbot-container');
    const chatToggleBtn = document.getElementById('chatToggle');

    function setChatOpen(open) {
        chatEl.classList.toggle('open', open);
        chatToggleBtn.setAttribute('aria-expanded', String(open));
    }

    // Start closed by default
    setChatOpen(false);

    chatToggleBtn.addEventListener('click', () => {
        setChatOpen(!chatEl.classList.contains('open'));
    });

    // Initialize everything when page loads
    window.addEventListener('load', () => {
        if (typeof THREE === 'undefined') {
            console.error('Three.js not loaded');
            return;
        }
        initLoaders();      // ✅ NEW: set up GLTFLoader (+ DRACOLoader if used)
          initThreeJS();      // your scene/camera/renderer/lights
          createCharacter();  // ✅ NEW: load the first GLB (based on currentCharacterIndex)
          animate?.();
        
        document.getElementById('prevArrow')?.addEventListener('click', window.previousCharacter);
        document.getElementById('nextArrow')?.addEventListener('click', window.nextCharacter);
    });
</script>

<script>
(function () {
  const emailInput = document.getElementById('loginEmail');   // your modal email input
  const loginBtn   = document.getElementById('loginSubmit');  // your modal button

  if (!emailInput || !loginBtn) return; // modal not on this page

  function magicRedirect() {
    const isInIframe = window !== window.top;
    // Same logic as your working page: always return to /packs
    return isInIframe
      ? 'https://ouchworld.netlify.app/landing-page'
      : `${location.origin}/landing-page`;
  }

  loginBtn.addEventListener('click', async (e) => {
    e.preventDefault();
    const email = (emailInput.value || '').trim();
    if (!email) return alert('Enter your email');
    if (!window.supa?.auth) return alert('Auth not initialized');

    loginBtn.disabled = true; const old = loginBtn.textContent; loginBtn.textContent = 'Sending…';
    const { error } = await window.supa.auth.signInWithOtp({
      email,
      options: { emailRedirectTo: magicRedirect() }
    });
    loginBtn.disabled = false; loginBtn.textContent = old;

    if (error) alert(error.message);
    else alert('Check your email for the magic link!');
  });
})();
</script>

<script>
  // Prevent double-tap zoom
  (function () {
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (e) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        e.preventDefault(); // cancel the second tap
      }
      lastTouchEnd = now;
    }, { passive: false });
  })();
</script>
<script>
// 1) Kill iOS pinch gestures (Safari fires these)
document.addEventListener('gesturestart',  e => e.preventDefault(), { passive: false });
document.addEventListener('gesturechange', e => e.preventDefault(), { passive: false });
document.addEventListener('gestureend',    e => e.preventDefault(), { passive: false });

// 2) Block multi-touch zoom attempts
document.addEventListener('touchstart', function (e) {
  if (e.touches && e.touches.length > 1) e.preventDefault();
}, { passive: false });

document.addEventListener('touchmove', function (e) {
  // Some iOS versions expose e.scale during pinch; block when not neutral
  if (typeof e.scale === 'number' && e.scale !== 1) e.preventDefault();
}, { passive: false });

// 3) Stop double-tap-to-zoom without breaking single taps
(function () {
  let lastTouchEnd = 0;
  document.addEventListener('touchend', function (e) {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) {
      e.preventDefault(); // suppress the second tap
    }
    lastTouchEnd = now;
  }, { passive: false });
})();
</script>

</body>
</html>
