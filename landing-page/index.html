<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LandingPage</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script>
    // Safe to expose in client
    window.__SUPABASE_URL = 'https://srdwkfjterotzjwzoauj.supabase.co';
    window.__SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNyZHdrZmp0ZXJvdHpqd3pvYXVqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU4NjU5NTksImV4cCI6MjA3MTQ0MTk1OX0.c0mJbQsfJMmqLiulXdZfWscd7J507buzRXkd700ymAQ';
  </script>
  <script>
    window.supa = window.supabase.createClient(
      window.__SUPABASE_URL,
      window.__SUPABASE_ANON_KEY
    );
  </script>
  <script>
    (async function () {
      try {
        if (window.supa && location.hash && location.hash.includes('access_token')) {
          const params = new URLSearchParams(location.hash.slice(1));
          const access_token = params.get('access_token');
          const refresh_token = params.get('refresh_token');
          const error = params.get('error');
          const error_description = params.get('error_description');
          if (error) {
            alert(`Authentication error: ${error_description || error}`);
            history.replaceState({}, '', location.pathname + location.search);
            return;
          }
          if (access_token && refresh_token) {
            const { error } = await window.supa.auth.setSession({ access_token, refresh_token });
            if (error) alert(`Session error: ${error.message}`); else window.location.reload();
          }
          history.replaceState({}, '', location.pathname + location.search);
        }
      } catch (e) { console.error('[supabase] Magic link processing failed:', e); }
    })();
  </script>

  <title>landing-page</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #000; color: #fff;
      touch-action: none;
      -ms-touch-action: none;
    }

    .container { width: 100vw; height: 100vh; position: relative; }
    #scene-container { position: absolute; inset: 0; z-index: 1; }
    #scene-container canvas { display: block; cursor: pointer; }

    /* Top navigation */
    .top-nav {
      position: fixed; top: 0; left: 0; right: 0; z-index: 100;
      display: flex; justify-content: space-between; align-items: center; padding: 20px;
    }
    .menu-button, .login-button {
      width: 30px; height: 30px;
      background: #000;
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 50%;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: border-color .2s ease, background .2s ease;
    }
    .menu-button:hover, .login-button:hover { border-color: rgba(255, 255, 255, 0.45); }
    .menu-dots { display: flex; gap: 4px; }
    .dot { width: 3px; height: 3px; background: #fff; border-radius: 50%; }
    .user-icon { width: 16px; height: 16px; color: #fff; }
    .user-icon svg { width: 100%; height: 100%; fill: currentColor; }

    /* Menu tray */
    .menu-tray {
      position: fixed; top: 60px; left: 20px; width: 130px;
      background: rgba(0, 0, 0, 1); backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; z-index: 200;
      transform: translateY(-20px); opacity: 0; visibility: hidden; transition: all .3s ease; padding: 10px 0;
    }
    .menu-tray.open { transform: translateY(0); opacity: 1; visibility: visible; }

    .menu-item { position: relative; display: block; width: 100%; padding: 6px 15px; color: #fff; text-decoration: none; font-size: 14px; font-weight: 300; cursor: pointer; background: none; border: 0; }
    .menu-item::before { content: ""; position: absolute; inset: 1px; left: 8px; right: 8px; border-radius: 8px; background: rgba(255,255,255,0.12); opacity: 0; transform: scaleY(0.96); transition: opacity .15s ease, transform .2s ease; pointer-events: none; }
    .menu-item:hover::before, .menu-item:focus-visible::before { opacity: 1; transform: scaleY(1); }
    .menu-item, .menu-item * { position: relative; z-index: 1; }
    .menu-item .menu-pill { background: transparent !important; padding: 0 !important; border-radius: 0 !important; }

    /* Modal */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 300; display: none; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
    .modal-overlay.show { display: flex; }
    .login-modal { background: rgba(0,0,0,0.9); backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.2); border-radius: 16px; padding: 15px; width: 90%; max-width: 400px; position: relative; color: #fff; }
    .modal-close { position: absolute; top: 8px; right: 15px; background: none; border: none; color: rgba(255,255,255,0.6); font-size: 24px; cursor: pointer; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all .2s ease; }
    input, textarea, select { font-size: 16px; }
    button, a, .menu-button, .login-button, .chat-toggle, .send-button, .arrow-btn, .character-confirm { touch-action: manipulation; }
    .modal-close:hover { color: #fff; }
    .modal-tabs { display: flex; gap: 20px; margin-bottom: 20px; justify-content: center; }
    .modal-tab { background: none; border: none; color: rgba(255,255,255,0.6); font-size: 16px; padding: 8px 0; cursor: pointer; border-bottom: 2px solid transparent; transition: all .2s ease; }
    .modal-tab.active { color: #fff; }
    .form-group { margin-bottom: 12px; }
    .form-input { width: 100%; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; padding: 12px 15px; color: #fff; font-size: 16px; outline: none; }
    .form-input::placeholder { color: rgba(255,255,255,0.5); }
    .form-button { width: 100%; background: rgba(255,255,255,0.92); color: #000; border: none; border-radius: 8px; padding: 12px; font-size: 14px; font-weight: 500; cursor: pointer; }

    /* Chat + Character selector (unchanged styles) */
    /* ... (keeping all your existing styles here) ... */
  </style>
</head>
<body>

<div class="container">
  <div id="scene-container"></div>

  <!-- Top Navigation -->
  <div class="top-nav">
    <button class="menu-button" onclick="toggleMenu()">
      <div class="menu-dots"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
    </button>
    <button class="login-button" onclick="handleLogin()">
      <div class="user-icon">
        <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
      </div>
    </button>
  </div>

  <!-- Menu Tray -->
  <div class="menu-tray" id="menuTray">
    <a href="/landing-page/" class="menu-item"><span class="menu-pill">Home</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Label</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Merch</span></a>
    <a href="/packs/" class="menu-item"><span class="menu-pill">Packs</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Inventory</span></a>
  </div>

  <!-- Character Selector -->
  <div class="character-controls" id="characterControls">
    <div class="character-info">
      <div class="character-header">
        <button class="arrow-btn" id="prevArrow" title="Previous">‹</button>
        <div class="character-name" id="characterName">Default Character</div>
        <button class="arrow-btn" id="nextArrow" title="Next">›</button>
      </div>
      <div class="character-actions">
        <button class="character-confirm" onclick="window.confirmCharacter()">Select</button>
      </div>
    </div>
  </div>

  <!-- Login Modal (unchanged markup) -->
  <div class="modal-overlay" id="loginModal">
    <div class="login-modal">
      <button class="modal-close" onclick="closeLoginModal()">&times;</button>
      <div class="modal-tabs">
        <button class="modal-tab active" onclick="switchTab('login')">Account</button>
      </div>
      <div id="loginForm">
        <div class="form-group">
          <input type="email" id="loginEmail" class="form-input" placeholder="Email" required>
        </div>
        <button id="loginSubmit" class="form-button">Create / Login</button>
      </div>
      <div id="signupForm" style="display:none;">
        <div class="form-group"><input type="text" class="form-input" placeholder="Username"></div>
        <div class="form-group"><input type="email" class="form-input" placeholder="Email"></div>
        <button class="form-button">Sign Up</button>
      </div>
    </div>
  </div>

  <!-- Chatbot (unchanged markup) -->
  <div class="chatbot-container">
    <div class="chat-messages" id="chatMessages"><div class="message bot">Hi there, how can I help?</div></div>
    <div class="chat-input-container">
      <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." onkeypress="handleKeyPress(event)"/>
      <button class="send-button" onclick="sendMessage()">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
      </button>
    </div>
  </div>
  <button class="chat-toggle" id="chatToggle" aria-label="Toggle chat">💱</button>
</div>

<script>
  // ===== Globals =====
  let scene, camera, renderer;
  let raycaster, mouseNDC, hoverActive = false, lastHoverState = false, hoverLight = null;
  let gltfLoader, dracoLoader;
  let currentModel = null, currentMixer = null, loadVersion = 0;
  const clock = new THREE.Clock();

  // expose for other code
  window.scene = null; window.camera = null; window.renderer = null; window.character = null;
  window.currentCharacterIndex = 0;

  function initLoaders() {
    gltfLoader = new THREE.GLTFLoader();
    dracoLoader = new THREE.DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
    gltfLoader.setDRACOLoader(dracoLoader);
  }

  window.characterConfigs = [
    { name: "Sloucho", status: "Unlocked", url: "/assets/models/sloucho.glb", targetHeight: 1.4, y: -0.08, scaleMul: 0.6, trimStart: 1.5, trimEnd: 2.0 },
    { name: "Ras",     status: "Unlocked", url: "/assets/models/ras.glb",     targetHeight: 1.4, scaleMul: 0.95, trimStart: 0.12, trimEnd: 0.10 },
    { name: "Super Maramu 2000", status: "Locked", url: "/assets/models/maramu.glb", targetHeight: 1.4, scaleMul: 0.95, trimStart: 0.12, trimEnd: 0.10 }
  ];

  function centerAndScaleToHeight(root, targetHeight = 1.8) {
    const box = new THREE.Box3().setFromObject(root);
    const size = new THREE.Vector3(); box.getSize(size);
    const center = new THREE.Vector3(); box.getCenter(center);
    root.position.sub(center);
    root.position.y += targetHeight * 0.5;
    const h = Math.max(size.y, 1e-6);
    const s = targetHeight / h;
    root.scale.multiplyScalar(s);
  }

    function frameCameraOnTargetHeight(camera, targetHeight = 1.8, pad = 1.4, centerYFactor = 0.5) {
      // pad > 1 adds margin around the model's height; 1.4 is a safe default
      const fovRad = (camera.fov * Math.PI) / 180;
      const halfH  = (targetHeight * pad) / 2;
      const dist   = halfH / Math.tan(fovRad / 2);

      const cy = targetHeight * centerYFactor; // 0.5 = exact mid-height
      camera.position.set(0, cy, dist);
      camera.lookAt(0, cy, 0);
      camera.updateProjectionMatrix();
    }


  function tickAnimations() {
    const dt = Math.min(clock.getDelta(), 0.033);
    if (currentMixer) currentMixer.update(dt);
  }

  // ===== Character UI (unchanged) =====
  window.updateCharacterInfo = function() {
    const config = window.characterConfigs[window.currentCharacterIndex];
    const nameEl = document.getElementById('characterName');
    const confirmBtn = document.querySelector('.character-confirm');
    if (!config || !nameEl) return;
    nameEl.textContent = config.name;
    if (confirmBtn) {
      const locked = config.status === 'Locked';
      confirmBtn.disabled = locked;
      confirmBtn.style.opacity = locked ? '0.5' : '1';
      confirmBtn.textContent = locked ? 'Locked' : 'Select';
    }
  };
  window.previousCharacter = function() {
    window.currentCharacterIndex = (window.currentCharacterIndex - 1 + window.characterConfigs.length) % window.characterConfigs.length;
    window.createCharacter?.(); window.updateCharacterInfo();
  };
  window.nextCharacter = function() {
    window.currentCharacterIndex = (window.currentCharacterIndex + 1) % window.characterConfigs.length;
    window.createCharacter?.(); window.updateCharacterInfo();
  };
  window.confirmCharacter = function() { const cfg = window.characterConfigs[window.currentCharacterIndex]; if (cfg && cfg.status === 'Unlocked') window.hideCharacterControls(); };
  window.hideCharacterControls = function() { document.getElementById('characterControls')?.classList.remove('show'); lastHoverState = null; };
  window.onCharacterClick = function() { const c = document.getElementById('characterControls'); if (c) { c.classList.add('show'); window.updateCharacterInfo(); } };

  // ===== Character Factory (fixed) =====
  window.createCharacter = function () {
    if (!window.scene || !gltfLoader) { console.error('Loaders/scene not ready'); return; }

    // Remove any leftover character not tracked in currentModel
    if (window.character && window.character !== currentModel) {
      try { scene.remove(window.character); } catch {}
      try { disposeObject(window.character); } catch {}
      window.character = null;
    }

    // Stop previous animations + remove previous model
    if (currentMixer) {
      try { currentMixer.stopAllAction(); } catch {}
      try { if (currentModel) currentMixer.uncacheRoot(currentModel); } catch {}
      currentMixer = null;
    }
    if (currentModel) { scene.remove(currentModel); disposeObject(currentModel); currentModel = null; }

    // Resolve config
    const list = window.characterConfigs || [];
    const idx = (window.currentCharacterIndex ?? 0) % (list.length || 1);
    const cfg = list[idx];
    if (!cfg || !cfg.url) return;

    const myVersion = ++loadVersion;
    console.log('Loading GLB:', cfg.url);

    gltfLoader.load(
      cfg.url,
      (gltf) => {
        if (myVersion !== loadVersion) { if (gltf.scene) disposeObject(gltf.scene); return; }

        // ✅ define root before using it
        const root = gltf.scene || gltf.scenes?.[0];
        if (!root) return;

        // Normalize size + center
        const targetHeight = cfg.targetHeight ?? 1.8;
        centerAndScaleToHeight(root, targetHeight);

        // ✅ optional fine-tune overall size (leave cfg.scaleMul undefined if you don’t need it)
        if (cfg.scaleMul) root.scale.multiplyScalar(cfg.scaleMul);

        // Defaults
        root.traverse(o => { if (o.isMesh) { o.castShadow = true; o.receiveShadow = true; } });

        // --- ✅ Animations (trim start/end + ping-pong loop) ---
        if (gltf.animations && gltf.animations.length) {
          currentMixer = new THREE.AnimationMixer(root);

          // Prefer an "Idle" clip; else first
          const clips = gltf.animations;
          const baseClip =
            THREE.AnimationClip.findByName(clips, 'Idle') ||
            THREE.AnimationClip.findByName(clips, 'idle') ||
            clips[0];

          // Trim a few frames off start/end (seconds)
          const trimStart = Math.max(0, cfg.trimStart ?? 1.5);
          const trimEnd   = Math.max(0, cfg.trimEnd   ?? 2.0);

          const minDur = 0.05; // safety so we never create a 0-length subclip
          const startSec = Math.min(trimStart, Math.max(0, baseClip.duration - minDur));
          const endSec   = Math.max(baseClip.duration - trimEnd, startSec + minDur);

          // Create a trimmed subclip; use fps so start/end are in seconds
          const fps = 30;
          const startFrame = Math.max(0, Math.floor(startSec * fps));
          const endFrame   = Math.max(startFrame + 1, Math.ceil(endSec * fps));
          const sub = THREE.AnimationUtils.subclip(
            baseClip,
            (baseClip.name || 'clip') + '_trim',
            startFrame,
            endFrame,
            fps
          );

          const action = currentMixer.clipAction(sub);
          action
            .setLoop(THREE.LoopPingPong, Infinity) // ← ping-pong removes end→start jump
            .reset()
            .fadeIn(0.25)
            .play();

          console.log('Clips:', clips.map(c => c.name), 'Trimmed:', { startSec, endSec, duration: sub.duration });
        } else {
          currentMixer = null;
          console.warn('No animations found in GLB:', cfg.url);
        }
        // --- end animations ---

        root.name = 'CHARACTER';
        scene.add(root);
        currentModel = root;
        window.character = root;

        frameCameraOnTargetHeight(camera, targetHeight, 1.4, 0.5);
        window.updateCharacterInfo?.();
      },
      undefined,
      (err) => console.error('GLB load error for', cfg.url, err)
    );
  };

  // Free GPU memory when swapping models
  function disposeObject(obj) {
    obj?.traverse?.((node) => {
      if (node.isMesh) {
        node.geometry?.dispose?.();
        const mat = node.material;
        if (Array.isArray(mat)) {
          mat.forEach(m => { m.map?.dispose?.(); m.normalMap?.dispose?.(); m.roughnessMap?.dispose?.(); m.metalnessMap?.dispose?.(); m.emissiveMap?.dispose?.(); m.dispose?.(); });
        } else if (mat) {
          mat.map?.dispose?.(); mat.normalMap?.dispose?.(); mat.roughnessMap?.dispose?.(); mat.metalnessMap?.dispose?.(); mat.emissiveMap?.dispose?.(); mat.dispose?.();
        }
      }
    });
  }

  // ===== Three.js Setup =====
  function initThreeJS() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    window.scene = scene;

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);
    window.camera = camera;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Make PBR/glTF materials look right and a bit brighter
    renderer.outputEncoding = THREE.sRGBEncoding;              // correct gamma
    renderer.toneMapping = THREE.ACESFilmicToneMapping;        // nicer rolloff
    renderer.toneMappingExposure = 1.25;                       // bump global exposure (try 1.2–1.5)


    // ✅ append the canvas so it’s visible
    const container = document.getElementById('scene-container');
    container.innerHTML = '';
    container.appendChild(renderer.domElement);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x1a1a2a, 0.7);
    scene.add(hemi);

    // Key light: main light from front-right, casts shadows
    const key = new THREE.DirectionalLight(0xffffff, 1.6);
    key.position.set(5, 8, 6);
    key.castShadow = true;
    key.shadow.mapSize.set(2048, 2048);
    key.shadow.camera.near = 0.1;
    key.shadow.camera.far = 50;
    scene.add(key);

    // Fill light: softens shadows from front-left, no shadows
    const fill = new THREE.DirectionalLight(0xffffff, 0.7);
    fill.position.set(-4, 5, 6);
    fill.castShadow = false;
    scene.add(fill);

    // Rim/back light: subtle colored edge from behind
    const rim = new THREE.DirectionalLight(0x88aaff, 0.5);
    rim.position.set(-5, 2, -6);
    rim.castShadow = false;
    scene.add(rim);

    // Raycasting
    raycaster = new THREE.Raycaster();
    mouseNDC = new THREE.Vector2();

    // Events (bind once)
    renderer.domElement.addEventListener('click', onCanvasClick);
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('mousemove', onMouseMove);

    setFixedTitleWidth("Super Maramu 2000");
  }

  function animate() {
    // ✅ keep the loop running and update mixer once
    requestAnimationFrame(animate);
    tickAnimations();
    renderer.render(scene, camera);
  }

  function onCanvasClick(e) {
    if (!window.character || !camera || !renderer) return;
    const rect = renderer.domElement.getBoundingClientRect();
    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
    raycaster.setFromCamera({ x, y }, camera);
    const hits = raycaster.intersectObjects(window.character.children, true);
    if (hits.length > 0) window.onCharacterClick();
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onMouseMove(e) {
    mouseNDC.x =  (e.clientX / window.innerWidth)  * 2 - 1;
    mouseNDC.y = -(e.clientY / window.innerHeight) * 2 + 1;
    checkHover();
  }

  function selectorOpen() {
    return !!document.getElementById('characterControls')?.classList.contains('show');
  }

  function checkHover() {
    if (!window.character) return;
    if (selectorOpen()) {
      if (lastHoverState) { setCharacterHighlight(false); lastHoverState = false; }
      return;
    }
    raycaster.setFromCamera(mouseNDC, camera);
    const intersects = raycaster.intersectObjects(window.character.children, true);
    hoverActive = intersects.length > 0;
    if (hoverActive !== lastHoverState) { setCharacterHighlight(hoverActive); lastHoverState = hoverActive; }
  }

  function setCharacterHighlight(active) {
    if (!window.scene || !window.character) return;
    if (active) {
      if (!hoverLight) {
        hoverLight = new THREE.PointLight(0x88aaff, 0.35, 3, 2);
        hoverLight.castShadow = false;
        hoverLight.position.set(0, 1.2, 1.6);
        window.character.add(hoverLight);
      }
    } else {
      if (hoverLight) { hoverLight.parent?.remove(hoverLight); hoverLight = null; }
      window.character.traverse(obj => {
        if (obj.isMesh && obj.material && 'emissive' in obj.material) {
          obj.material.emissive.setHex(0x000000);
        }
      });
    }
  }

  function setFixedTitleWidth(ghostString) {
    const nameEl = document.getElementById('characterName');
    if (!nameEl) return;
    const measurer = document.createElement('span');
    measurer.style.position = 'absolute';
    measurer.style.visibility = 'hidden';
    measurer.style.whiteSpace = 'nowrap';
    measurer.style.fontFamily = getComputedStyle(nameEl).fontFamily;
    measurer.style.fontSize = getComputedStyle(nameEl).fontSize;
    measurer.style.fontWeight = getComputedStyle(nameEl).fontWeight;
    measurer.textContent = ghostString;
    document.body.appendChild(measurer);
    const width = Math.ceil(measurer.getBoundingClientRect().width);
    document.body.removeChild(measurer);
    document.documentElement.style.setProperty('--title-width', width + 'px');
    const info = document.querySelector('.character-info'); if (info) { void getComputedStyle(info).width; }
  }

  // ===== UI bits (unchanged) =====
  function toggleMenu() { document.getElementById('menuTray').classList.toggle('open'); }
  function handleLogin() { document.getElementById('loginModal').classList.add('show'); }
  function closeLoginModal() { document.getElementById('loginModal').classList.remove('show'); }
  function switchTab(tab) {
    const tabs = document.querySelectorAll('.modal-tab');
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    tabs.forEach(t => t.classList.remove('active'));
    if (tab === 'login') { tabs[0].classList.add('active'); loginForm.style.display = 'block'; signupForm.style.display = 'none'; }
    else { tabs[1].classList.add('active'); loginForm.style.display = 'none'; signupForm.style.display = 'block'; }
  }

  document.addEventListener('click', function(e) {
    const tray = document.getElementById('menuTray');
    const btn = document.querySelector('.menu-button');
    if (tray && !tray.contains(e.target) && !btn.contains(e.target)) tray.classList.remove('open');
  });
  document.getElementById('loginModal').addEventListener('click', function(e) { if (e.target === this) closeLoginModal(); });

  function handleKeyPress(e) { if (e.key === 'Enter') sendMessage(); }
  function sendMessage() {
    const input = document.getElementById('chatInput');
    const text = input.value.trim();
    if (!text) return;
    addMessage(text, 'user');
    input.value = '';
    setTimeout(() => addMessage(generateBotResponse(text), 'bot'), 500);
  }
  function addMessage(text, sender) {
    const box = document.getElementById('chatMessages');
    if (!box) return;
    const div = document.createElement('div');
    div.className = `message ${sender}`;
    div.textContent = text;
    box.appendChild(div);
    box.scrollTop = box.scrollHeight;
  }
  function generateBotResponse(msg) {
    const m = msg.toLowerCase();
    if (m.includes('hello')) return "Hello! Welcome to the character showcase. How can I help you today?";
    if (m.includes('hi')) return "Hi there! I'm here to help you navigate the site. What would you like to know?";
    if (m.includes('help')) return "I can help you with information about the character, navigation, or features of this site.";
    if (m.includes('character')) return "This is a 3D character model you can click to open the selector.";
    if (m.includes('website')) return "This website showcases 3D character models with interactive features.";
    if (m.includes('menu')) return "Click the three dots in the top-left to open the menu.";
    if (m.includes('login')) return "Click the user icon in the top-right to open login.";
    return "Thanks for your message! Ask about the character, website features, or navigation.";
  }

  const chatEl = document.querySelector('.chatbot-container');
  const chatToggleBtn = document.getElementById('chatToggle');
  function setChatOpen(open) { chatEl.classList.toggle('open', open); chatToggleBtn.setAttribute('aria-expanded', String(open)); }
  setChatOpen(false);
  chatToggleBtn.addEventListener('click', () => { setChatOpen(!chatEl.classList.contains('open')); });

  // ===== Start =====
  window.addEventListener('load', () => {
    if (typeof THREE === 'undefined') { console.error('Three.js not loaded'); return; }
    initLoaders();
    initThreeJS();
    createCharacter();   // exactly one initial load
    animate();
    document.getElementById('prevArrow')?.addEventListener('click', window.previousCharacter);
    document.getElementById('nextArrow')?.addEventListener('click', window.nextCharacter);
  });
</script>

<script>
  (function () {
    const emailInput = document.getElementById('loginEmail');
    const loginBtn   = document.getElementById('loginSubmit');
    if (!emailInput || !loginBtn) return;
    function magicRedirect() {
      const isInIframe = window !== window.top;
      return isInIframe ? 'https://ouchworld.netlify.app/landing-page' : `${location.origin}/landing-page`;
    }
    loginBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      const email = (emailInput.value || '').trim();
      if (!email) return alert('Enter your email');
      if (!window.supa?.auth) return alert('Auth not initialized');
      loginBtn.disabled = true; const old = loginBtn.textContent; loginBtn.textContent = 'Sending…';
      const { error } = await window.supa.auth.signInWithOtp({ email, options: { emailRedirectTo: magicRedirect() } });
      loginBtn.disabled = false; loginBtn.textContent = old;
      if (error) alert(error.message); else alert('Check your email for the magic link!');
    });
  })();
</script>

<!-- Mobile zoom suppression (unchanged) -->
<script>
  (function () {
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (e) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });
  })();
  document.addEventListener('gesturestart',  e => e.preventDefault(), { passive: false });
  document.addEventListener('gesturechange', e => e.preventDefault(), { passive: false });
  document.addEventListener('gestureend',    e => e.preventDefault(), { passive: false });
  document.addEventListener('touchstart', function (e) { if (e.touches && e.touches.length > 1) e.preventDefault(); }, { passive: false });
  document.addEventListener('touchmove', function (e) { if (typeof e.scale === 'number' && e.scale !== 1) e.preventDefault(); }, { passive: false });
</script>

</body>
</html>
