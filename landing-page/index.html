<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LandingPage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script>
    // Safe to expose in client
    window.__SUPABASE_URL = 'https://srdwkfjterotzjwzoauj.supabase.co';
    window.__SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNyZHdrZmp0ZXJvdHpqd3pvYXVqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU4NjU5NTksImV4cCI6MjA3MTQ0MTk1OX0.c0mJbQsfJMmqLiulXdZfWscd7J507buzRXkd700ymAQ';
  </script>
  <script>
    window.supa = window.supabase.createClient(
      window.__SUPABASE_URL,
      window.__SUPABASE_ANON_KEY
    );
  </script>
  <script>
    (async function () {
      try {
        if (window.supa && location.hash && location.hash.includes('access_token')) {
          const params = new URLSearchParams(location.hash.slice(1));
          const access_token = params.get('access_token');
          const refresh_token = params.get('refresh_token');
          const error = params.get('error');
          const error_description = params.get('error_description');
          if (error) {
            alert(`Authentication error: ${error_description || error}`);
            history.replaceState({}, '', location.pathname + location.search);
            return;
          }
          if (access_token && refresh_token) {
            const { error } = await window.supa.auth.setSession({ access_token, refresh_token });
            if (error) alert(`Session error: ${error.message}`); else window.location.reload();
          }
          history.replaceState({}, '', location.pathname + location.search);
        }
      } catch (e) { console.error('[supabase] Magic link processing failed:', e); }
    })();
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #000; color: #fff;
      touch-action: none;
      -ms-touch-action: none;
    }

    .container { width: 100vw; height: 100vh; position: relative; }
    #scene-container { position: absolute; inset: 0; z-index: 1; }
    #scene-container canvas { display: block; cursor: pointer; }

    /* Top navigation */
    .top-nav {
      position: fixed; top: 0; left: 0; right: 0; z-index: 100;
      display: flex; justify-content: space-between; align-items: center; padding: 20px;
    }
    .menu-button, .login-button {
      width: 30px; height: 30px;
      background: #000;
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 50%;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: border-color .2s ease, background .2s ease;
    }
    .menu-button:hover, .login-button:hover { border-color: rgba(255, 255, 255, 0.45); }
    .menu-dots { display: flex; gap: 4px; }
    .dot { width: 3px; height: 3px; background: #fff; border-radius: 50%; }
    .user-icon { width: 16px; height: 16px; color: #fff; }
    .user-icon svg { width: 100%; height: 100%; fill: currentColor; }

    /* Menu tray */
    .menu-tray {
      position: fixed; top: 60px; left: 20px; width: 130px;
      background: rgba(0, 0, 0, 1); backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; z-index: 200;
      transform: translateY(-20px); opacity: 0; visibility: hidden; transition: all .3s ease; padding: 10px 0;
    }
    .menu-tray.open { transform: translateY(0); opacity: 1; visibility: visible; }

    .menu-item { position: relative; display: block; width: 100%; padding: 6px 15px; color: #fff; text-decoration: none; font-size: 14px; font-weight: 300; cursor: pointer; background: none; border: 0; }
    .menu-item::before { content: ""; position: absolute; inset: 1px; left: 8px; right: 8px; border-radius: 8px; background: rgba(255,255,255,0.12); opacity: 0; transform: scaleY(0.96); transition: opacity .15s ease, transform .2s ease; pointer-events: none; }
    .menu-item:hover::before, .menu-item:focus-visible::before { opacity: 1; transform: scaleY(1); }
    .menu-item, .menu-item * { position: relative; z-index: 1; }
    .menu-item .menu-pill { background: transparent !important; padding: 0 !important; border-radius: 0 !important; }

    /* Modal */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 300; display: none; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
    .modal-overlay.show { display: flex; }
    .login-modal { background: rgba(0,0,0,0.9); backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.2); border-radius: 16px; padding: 15px; width: 90%; max-width: 400px; position: relative; color: #fff; }
    .modal-close { position: absolute; top: 8px; right: 15px; background: none; border: none; color: rgba(255,255,255,0.6); font-size: 24px; cursor: button; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all .2s ease; }
    input, textarea, select { font-size: 16px; }
    button, a, .menu-button, .login-button, .chat-toggle, .send-button, .arrow-btn, .character-confirm { touch-action: manipulation; }
    .modal-close:hover { color: #fff; }
    .modal-tabs { display: flex; gap: 20px; margin-bottom: 20px; justify-content: center; }
    .modal-tab { background: none; border: none; color: rgba(255,255,255,0.6); font-size: 16px; padding: 8px 0; cursor: pointer; border-bottom: 2px solid transparent; transition: all .2s ease; }
    .modal-tab.active { color: #fff; }
    .form-group { margin-bottom: 12px; }
    .form-input { width: 100%; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; padding: 12px 15px; color: #fff; font-size: 16px; outline: none; }
    .form-input::placeholder { color: rgba(255,255,255,0.5); }
    .form-button { width: 100%; background: rgba(255,255,255,0.92); color: #000; border: none; border-radius: 8px; padding: 12px; font-size: 14px; font-weight: 500; cursor: pointer; }

    /* Character selector overlay */
    .character-controls { position: fixed; left: 50%; bottom: 8vh; transform: translateX(-50%); z-index: 250; opacity: 0; pointer-events: none; transition: opacity .2s ease; }
    .character-controls.show { opacity: 1; pointer-events: auto; }
    .character-info { display: grid; grid-template-rows: auto auto; gap: 8px; justify-items: center; min-width: 260px; }
    .character-header { display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 10px; }
    .character-name { text-align: center; font: 600 14px/1 system-ui, Arial, sans-serif; background: none; padding: .35rem .6rem; border-radius: .5rem; min-width: var(--title-width, 200px); }
    .arrow-btn { background: none; border: none; color: #fff; width: 28px; height: 28px; text-align: center; font-size: 18px; line-height: 26px; cursor: pointer; }
    .character-actions { display: flex; justify-content: center; }
    .character-confirm { background: rgba(255,255,255,.92); color: #000; border-radius: 8px; padding: 8px 16px; border: none; cursor: pointer; font-weight: 600; pointer-events: auto;
        z-index: 9999; touch-action: manipulation; }
    
    
    /* Hide the selector bar entirely
    #characterControls { display: none !important; }

    /* If you ever show it again, these remove chrome:
    .character-name { background: none !important; padding: 0 !important; }
    .arrow-btn, .character-actions { display: none !important; }
     */

    /* Chat (unchanged styles trimmed for brevity)
    .chatbot-container { position: fixed; right: 16px; bottom: 16px; width: 320px; height: 420px; background: rgba(0,0,0,.8); border: 1px solid rgba(255,255,255,.15); border-radius: 12px; display: none; flex-direction: column; z-index: 260; }
    .chatbot-container.open { display: flex; }
    .chat-messages { flex: 1; overflow: auto; padding: 10px; }
    .message { margin: 6px 0; }
    .message.user { text-align: right; }
    .chat-input-container { display: flex; padding: 8px; gap: 8px; }
    .chat-input { flex: 1; padding: 8px; border-radius: 8px; border: 1px solid rgba(255,255,255,.2); background: rgba(255,255,255,.1); color: #fff; }
    .send-button { padding: 8px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,.2); background: rgba(255,255,255,.15); color: #fff; }
    .chat-toggle { position: fixed; right: 16px; bottom: 16px; z-index: 261; border: none; background: #111; color: #fff; padding: 10px 12px; border-radius: 50%; } */

  </style>
</head>
<body>

<div class="container">
  <div id="scene-container"></div>

  <!-- Top Navigation -->
  <div class="top-nav">
    <button class="menu-button" onclick="toggleMenu()">
      <div class="menu-dots"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
    </button>
    <button class="login-button" onclick="handleLogin()">
      <div class="user-icon">
        <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
      </div>
    </button>
  </div>

  <!-- Menu Tray -->
  <div class="menu-tray" id="menuTray">
    <a href="/landing-page/" class="menu-item"><span class="menu-pill">Home</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Label</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Merch</span></a>
    <a href="/packs/" class="menu-item"><span class="menu-pill">Packs</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Inventory</span></a>
  </div>

  <!-- Character Selector -->
  <div class="character-controls" id="characterControls">
    <div class="character-info">
      <div class="character-header">
        <button class="arrow-btn" id="prevArrow" title="Previous">‹</button>
        <div class="character-name" id="characterName">Default Character</div>
        <button class="arrow-btn" id="nextArrow" title="Next">›</button>
      </div>
      <div class="character-actions">
        <button class="character-confirm" onclick="window.confirmCharacter()">Select</button>
      </div>
    </div>
  </div>

  <!-- Login Modal -->
  <div class="modal-overlay" id="loginModal">
    <div class="login-modal">
      <button class="modal-close" onclick="closeLoginModal()">&times;</button>
      <div class="modal-tabs">
        <button class="modal-tab active" onclick="switchTab('login')">Account</button>
      </div>
      <div id="loginForm">
        <div class="form-group">
          <input type="email" id="loginEmail" class="form-input" placeholder="Email" required>
        </div>
        <button id="loginSubmit" class="form-button">Create / Login</button>
      </div>
      <div id="signupForm" style="display:none;">
        <div class="form-group"><input type="text" class="form-input" placeholder="Username"></div>
        <div class="form-group"><input type="email" class="form-input" placeholder="Email"></div>
        <button class="form-button">Sign Up</button>
      </div>
    </div>
  </div>

  <!-- Chatbot
  <div class="chatbot-container">
    <div class="chat-messages" id="chatMessages"><div class="message bot">Hi there, how can I help?</div></div>
    <div class="chat-input-container">
      <input type="text" class="chat-input" id="chatInput" placeholder="Type a message..." onkeypress="handleKeyPress(event)"/>
      <button class="send-button" onclick="sendMessage()">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
      </button>
    </div>
  </div>
  <button class="chat-toggle" id="chatToggle" aria-label="Toggle chat">💱</button>-->
</div>

<script>
  // ===== Globals =====
  let scene, camera, renderer;
  let raycaster, mouseNDC, hoverActive = false, lastHoverState = false, hoverLight = null;
  let gltfLoader, dracoLoader;
  let currentModel = null, currentMixer = null, loadVersion = 0;
  const clock = new THREE.Clock();

  // [CAROUSEL] state
  const carousel = {
    mode: 'view',                // 'view' | 'carousel'
    group: null,                 // THREE.Group holding side-by-side roots
    spacing: 1.8,                // horizontal spacing (world units)
    dragging: false,
    startX: 0,
    dx: 0,
    activeIndex: 0,              // which index is centered while in carousel
    mixers: [],                  // extra mixers for side items
    cache: []                    // [{root, mixer, targetHeight, cfg}]
  };
    
    // Carousel layout + tween parameters (safe at top-level)
    carousel.radius     = 3;
    carousel.anglePer   = Math.PI / 9.5;
    carousel.camHome    = null;        // set on first enterCarousel()
    carousel.dragOffset = 0;
    carousel.animFrom   = 0;
    carousel.animTo     = 0;
    carousel.animT      = 1;
    carousel.animDur    = 300;
    carousel.animStart  = 0;


  // expose for other code
  window.scene = null; window.camera = null; window.renderer = null; window.character = null;
  window.currentCharacterIndex = 0;

  function initLoaders() {
    gltfLoader = new THREE.GLTFLoader();
    dracoLoader = new THREE.DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
    gltfLoader.setDRACOLoader(dracoLoader);
  }

  window.characterConfigs = [
    { name: "Sloucho", status: "Unlocked", url: "/assets/models/sloucho.glb", targetHeight: 1.4, y: 0.02, scaleMul: 0.6, trimStart: 1.5, trimEnd: 2.0 },
    { name: "Ras",     status: "Unlocked", url: "/assets/models/ras.glb",     targetHeight: 1.4, y: 0.05, scaleMul: 0.6, trimStart: 0.12, trimEnd: 0.10 },
    { name: "Super Maramu 2000", status: "Unlocked", url: "/assets/models/maramu.glb", targetHeight: 1.4, y: -0.1, scaleMul: 0.5, trimStart: 0.12, trimEnd: 0.10 }
  ];

  function centerAndScaleToHeight(root, targetHeight = 1.8) {
    const box = new THREE.Box3().setFromObject(root);
    const size = new THREE.Vector3(); box.getSize(size);
    const center = new THREE.Vector3(); box.getCenter(center);
    root.position.sub(center);
    root.position.y += targetHeight * 0.5;
    const h = Math.max(size.y, 1e-6);
    const s = targetHeight / h;
    root.scale.multiplyScalar(s);
  }

  // Adjusted framing baseline (you previously used 0.2 center—keeping consistent)
  function frameCameraOnTargetHeight(camera, targetHeight = 1.8, pad = 1.4, centerYFactor = 0.2) {
    const fovRad = (camera.fov * Math.PI) / 180;
    const halfH  = (targetHeight * pad) / 2;
    const dist   = halfH / Math.tan(fovRad / 2);
    const cy = targetHeight * centerYFactor;
    camera.position.set(0, cy, dist);
    camera.lookAt(0, cy, 0);
    camera.updateProjectionMatrix();
  }

  function tickAnimations() {
    const dt = Math.min(clock.getDelta(), 0.033);
    if (currentMixer) currentMixer.update(dt);
    // [CAROUSEL] drive extra mixers when in carousel
    if (carousel.mode === 'carousel' && carousel.mixers.length) {
      for (const m of carousel.mixers) m.update(dt);
    }
  }

  // ===== Character UI =====
  window.updateCharacterInfo = function() {
    const config = window.characterConfigs[window.currentCharacterIndex];
    const nameEl = document.getElementById('characterName');
    const confirmBtn = document.querySelector('.character-confirm');
    if (!config || !nameEl) return;
    nameEl.textContent = config.name;
    if (confirmBtn) {
      const locked = config.status === 'Locked';
      confirmBtn.disabled = locked;
      confirmBtn.style.opacity = locked ? '0.5' : '1';
      confirmBtn.textContent = locked ? 'Locked' : 'Select';
    }
  };

  // These still work in view mode; in carousel they snap between items.
  window.previousCharacter = function() {
    if (carousel.mode === 'carousel') { snapToIndex(carousel.activeIndex - 1); return; }
    window.currentCharacterIndex = (window.currentCharacterIndex - 1 + window.characterConfigs.length) % window.characterConfigs.length;
    window.createCharacter?.(); window.updateCharacterInfo();
  };
  window.nextCharacter = function() {
    if (carousel.mode === 'carousel') { snapToIndex(carousel.activeIndex + 1); return; }
    window.currentCharacterIndex = (window.currentCharacterIndex + 1) % window.characterConfigs.length;
    window.createCharacter?.(); window.updateCharacterInfo();
  };

  // Commit selection (closes carousel if open)
  window.confirmCharacter = function() {
    const cfg = window.characterConfigs[window.currentCharacterIndex];
    if (!cfg) return;
    if (carousel.mode === 'carousel') {
      if (cfg.status === 'Locked') return; // keep button disabled UI already
      exitCarousel(true); // commit
      return;
    }
    if (cfg.status === 'Unlocked') window.hideCharacterControls();
  };

  window.hideCharacterControls = function() {
    document.getElementById('characterControls')?.classList.remove('show');
    lastHoverState = null;
  };

  // Click on model → enter carousel
  window.onCharacterClick = function() {
    if (carousel.mode === 'view') enterCarousel();
  };

  // ===== Character Factory (existing single-model loader) =====
  window.createCharacter = function () {
    if (!window.scene || !gltfLoader) { console.error('Loaders/scene not ready'); return; }

    // Remove any leftover character not tracked in currentModel
    if (window.character && window.character !== currentModel) {
      try { scene.remove(window.character); } catch {}
      try { disposeObject(window.character); } catch {}
      window.character = null;
    }

    // Stop previous animations + remove previous model
    if (currentMixer) {
      try { currentMixer.stopAllAction(); } catch {}
      try { if (currentModel) currentMixer.uncacheRoot(currentModel); } catch {}
      currentMixer = null;
    }
    if (currentModel) { scene.remove(currentModel); disposeObject(currentModel); currentModel = null; }

    const list = window.characterConfigs || [];
    const idx = (window.currentCharacterIndex ?? 0) % (list.length || 1);
    const cfg = list[idx];
    if (!cfg || !cfg.url) return;

    const myVersion = ++loadVersion;
    gltfLoader.load(
      cfg.url,
      (gltf) => {
        if (myVersion !== loadVersion) { if (gltf.scene) disposeObject(gltf.scene); return; }
        const root = gltf.scene || gltf.scenes?.[0];
        if (!root) return;

        const targetHeight = cfg.targetHeight ?? 1.8;

        // Center/scale first
        centerAndScaleToHeight(root, targetHeight);
        if (cfg.scaleMul) root.scale.multiplyScalar(cfg.scaleMul);

        // 🔧 Apply per-character Y offset ONCE and cache the stable baseY for carousel/layout
        root.userData = root.userData || {};
        if (cfg.y != null && !root.userData.yApplied) {
          root.position.y += cfg.y;
          root.userData.yApplied = true;
        }
        root.userData.baseY = root.position.y; // used by carousel to avoid Y "jumps"

        // ✅ Make meshes raycast-friendly (do this BEFORE animations & adding to scene)
        // ✅ Make meshes raycast-friendly + cache original emissive (BEFORE animations & add to scene)
        root.traverse((o) => {
          if (!o.isMesh) return;

          o.castShadow = true;
          o.receiveShadow = true;
          o.raycast = THREE.Mesh.prototype.raycast; // robust triangle raycast
          o.frustumCulled = false;                  // avoid cull-related miss clicks

          // Save original emissive so we can restore after hover/selection
          const store = (m) => {
            if (!m) return;
            m.userData = m.userData || {};
            if ('emissive' in m && !m.userData._origEmissive) {
              m.userData._origEmissive = m.emissive.clone();
            }
          };
          if (Array.isArray(o.material)) {
            o.material.forEach(store);
          } else {
            store(o.material);
          }
        });

        // ✅ Ensure transforms are fresh for first-frame raycasts
        root.updateMatrixWorld(true);

        // Animations (unchanged)
        if (gltf.animations && gltf.animations.length) {
          currentMixer = new THREE.AnimationMixer(root);
          const clips = gltf.animations;
          const baseClip =
            THREE.AnimationClip.findByName(clips, 'Idle') ||
            THREE.AnimationClip.findByName(clips, 'idle') ||
            clips[0];

          const trimStart = Math.max(0, cfg.trimStart ?? 1.5);
          const trimEnd   = Math.max(0, cfg.trimEnd   ?? 2.0);
          const minDur = 0.05;
          const startSec = Math.min(trimStart, Math.max(0, baseClip.duration - minDur));
          const endSec   = Math.max(baseClip.duration - trimEnd, startSec + minDur);
          const fps = 30;
          const startFrame = Math.max(0, Math.floor(startSec * fps));
          const endFrame   = Math.max(startFrame + 1, Math.ceil(endSec * fps));
          const sub = THREE.AnimationUtils.subclip(
            baseClip,
            (baseClip.name || 'clip') + '_trim',
            startFrame, endFrame, fps
          );

          const action = currentMixer.clipAction(sub);
          action.setLoop(THREE.LoopPingPong, Infinity)
                .reset()
                .setEffectiveWeight(1)
                .play();
          action.time = 1/60;      // pre-roll one frame
          currentMixer.update(0);  // pre-evaluate pose
        } else {
          currentMixer = null;
        }

        // Add to scene & keep refs
        root.name = 'CHARACTER';
        scene.add(root);
        currentModel = root;
        window.character = root;

        frameCameraOnTargetHeight(camera, targetHeight, 1.4, 0.2);
        window.updateCharacterInfo?.();
      },
      undefined,
      (err) => console.error('GLB load error for', cfg.url, err)
    );
  };


    function layoutCarousel(offsetInItems) {
      if (!carousel.group) return;
      const n = carousel.cache.length;

      const rel = (i, active) => {
        let d = ((i - active) % n + n) % n; // 0..n-1
        if (d > n / 2) d -= n;              // (-n/2 .. n/2]
        return d;
      };

      for (let i = 0; i < n; i++) {
        const entry = carousel.cache[i]; if (!entry) continue;
        const baseY = entry.baseY ?? 0;

        // k = wrapped slot index from center, including drag offset
        const k   = rel(i, carousel.activeIndex) - offsetInItems;
        const ang = k * (carousel.anglePer ?? (Math.PI / 10));

        const x = Math.sin(ang) * (carousel.radius ?? 1.8);
        const z = -(1 - Math.cos(ang)) * ((carousel.radius ?? 1.8) * 0.9);

        entry.root.position.set(x, baseY, z);
        entry.root.rotation.y = -ang * 0.6;

       
     const isCenter = Math.abs(k) <= 0.499; // halfway-to-next slot threshold
        if (isCenter) {
          entry.root.layers.enable(1);
        } else {
          entry.root.layers.disable(1);
        }
        // NEW: hide everything except the centered/active slot
        entry.root.visible = isCenter;
      }


      // Camera parallax, always looking near center
      const anglePer = carousel.anglePer ?? (Math.PI / 10);
      const rad = carousel.radius ?? 1.8;
      const camSlide = Math.sin(-offsetInItems * anglePer) * 0.5;
      const camDepth = carousel.camHome
        ? carousel.camHome.z + (1 - Math.cos(-offsetInItems * anglePer)) * (rad * 0.12)
        : camera.position.z;

      camera.position.x = THREE.MathUtils.lerp(camera.position.x, camSlide, 0.08);
      if (carousel.camHome) {
        camera.position.y = THREE.MathUtils.lerp(camera.position.y, carousel.camHome.y, 0.08);
      }
      camera.position.z = THREE.MathUtils.lerp(camera.position.z, camDepth, 0.08);
      const lookY = carousel.camHome ? carousel.camHome.y : 0;
     camera.lookAt(0, lookY, 0);
    }


    // Drive easing each frame (call from your animate loop)
    function updateCarouselTween() {
      if (carousel.mode !== 'carousel') return;
      // active easing?
      if (carousel.animT < 1) {
        const now = performance.now();
        const t = Math.min(1, (now - carousel.animStart) / carousel.animDur);
        // smoothstep-ish ease
        const u = t < 0.5
            ? 16 * t * t * t * t * t: 1 - Math.pow(-2 * t + 2, 5) / 2;
        const off = THREE.MathUtils.lerp(carousel.animFrom, carousel.animTo, u);
        layoutCarousel(off);
        carousel.animT = t;
        if (t === 1) {
          carousel.dragOffset = 0;         // finished
          if (typeof carousel.pendingIndex === 'number') {
            carousel.activeIndex = carousel.pendingIndex;  // now commit the center
            carousel.pendingIndex = null;
          }
        }

      } else {
        // while dragging, continuously lay out
        layoutCarousel(carousel.dragOffset || 0);
      }
    }

  // ===== Carousel implementation =====
  function enterCarousel() {
    // Show overlay (even if you hide it via CSS later)
    const c = document.getElementById('characterControls');
    if (c) c.classList.add('show');

    // Remember camera "home" once (used for parallax + exit)
    if (!carousel.camHome) {
      carousel.camHome = { x: camera.position.x, y: camera.position.y, z: camera.position.z };
    }

    carousel.mode = 'carousel';
    // Add inside enterCarousel(), after you set carousel.mode = 'carousel':
    {
      const L = scene.userData?.lights, LV = scene.userData?.lightLevels;
      if (L && LV) {
        L.hemi.intensity = LV.hemi * 0.25;
        L.key.intensity  = LV.key  * 0.35;
        L.fill.intensity = LV.fill * 0.25;
        L.rim.intensity  = LV.rim  * 0.25;
      }
    }

    carousel.activeIndex = window.currentCharacterIndex;
    

    if (!carousel.group) {
      carousel.group = new THREE.Group();
      carousel.group.name = 'CHAR_CAROUSEL_GROUP';
    }

    // Preload all entries, then build the carousel
    preloadAll().then(() => {
      // Remove single root; we’ll show via the group
      if (currentModel) scene.remove(currentModel);

      // Ensure every entry has a stable baseY (prevents vertical "pop")
      for (let i = 0; i < carousel.cache.length; i++) {
        const entry = carousel.cache[i];
        if (!entry || !entry.root) continue;
        if (typeof entry.baseY !== 'number') {
          entry.baseY = entry.root.userData?.baseY ?? entry.root.position.y;
        }
      }

      // Ensure dimming light is present during carousel (height uses baseY)
      if (!carousel.centerLight) {
        const yTop = (carousel.cache[carousel.activeIndex]?.baseY || 0) + 1.0;
        const pl = new THREE.PointLight(0xffffff, 1.15, 2.4, 2.2); // intensity, distance, decay
        pl.position.set(0, yTop, 0.7);
        pl.castShadow = false;
        pl.layers.set(1);
        scene.add(pl);
        carousel.centerLight = pl;
      } else if (!carousel.centerLight.parent) {
        scene.add(carousel.centerLight);
        carousel.centerLight.layers.set(1);
      }


      // (Re)build the group
      carousel.group.clear();
      window.character = null;

      for (let i = 0; i < carousel.cache.length; i++) {
        const entry = carousel.cache[i];
        if (!entry) continue;

        entry.root.visible = false;

        // Reset to a clean pose so arc layout starts from known state
        entry.root.position.set(0, entry.baseY ?? entry.root.position.y, 0);
        entry.root.rotation.set(0, 0, 0);

        carousel.group.add(entry.root);
      }

      scene.add(carousel.group);

      // Drive animations for all items while in carousel
      startCarouselAnimations();

      // Input + state
      carousel.dragOffset = 0;
      carousel.animFrom = 0;
      carousel.animTo = 0;
      carousel.animT = 1;

      window.updateCharacterInfo?.();
      attachCarouselInput();

      // Initial arc layout NOW that everything is in the scene
      layoutCarousel(0);
    });
  }


    function exitCarousel(commitSelection) {
      // Stop swipe handlers
      detachCarouselInput();

      // Remove the focus/dimming light (only used in carousel)
      if (carousel.centerLight && carousel.centerLight.parent) {
        scene.remove(carousel.centerLight);
      }

      // Remove the side-by-side group from the scene
      if (carousel.group) {
        try { carousel.group.clear(); } catch {}
        if (carousel.group.parent) scene.remove(carousel.group);
      }

      // Decide which index to commit
      const commitIndex = commitSelection ? carousel.activeIndex : window.currentCharacterIndex;
      const entry = carousel.cache[commitIndex];

      // Safety: ensure all materials are fully opaque again
      for (let i = 0; i < carousel.cache.length; i++) {
        const e = carousel.cache[i];
        if (!e) continue;
        // Reset material opacity for all meshes
        e.root.traverse(o => {
          if (o.isMesh && o.material) {
            if (Array.isArray(o.material)) {
                o.material.forEach(m => {
                            m.transparent = false; m.opacity = 1;
                            if ('emissive' in m && m.userData && m.userData._origEmissive) {
                              m.emissive.copy(m.userData._origEmissive);
                            }
                          });
            } else {
              o.material.transparent = false;
              o.material.opacity = 1;
              if ('emissive' in o.material && o.material.userData && o.material.userData._origEmissive) {
                          o.material.emissive.copy(o.material.userData._origEmissive);
                    }
            }
          }
        });
        // Default: hide non-committed entries, center committed one
        if (typeof commitIndex !== 'undefined') {
          e.root.visible = (i === commitIndex);
        }
        // Reset local transforms so the active model faces forward
        e.root.position.set(0, e.root.position.y, 0);
        e.root.rotation.set(0, 0, 0);
        e.root.layers.disable(1);
      }

      // Keep only the committed model in the scene
      if (entry) {
        for (let i = 0; i < carousel.cache.length; i++) {
          const e = carousel.cache[i];
          if (!e) continue;
          e.root.visible = (i === commitIndex);
          // Reset X/Z so the committed model is centered again
          e.root.position.set(0, e.root.position.y, 0);
        }

        // Ensure the committed root is attached to the scene
        if (!entry.root.parent) scene.add(entry.root);

        // Update references to the active model + mixer
        currentModel = entry.root;
        window.character = entry.root;
        currentMixer = entry.mixer || null;

        // Persist the selection in your local state
        window.currentCharacterIndex = commitIndex;

        // Reframe camera for the committed model's height
        frameCameraOnTargetHeight(camera, entry.targetHeight ?? 1.4, 1.4, 0.2);

        // Return camera to its "home" slide position if defined
        if (carousel.camHome) {
          camera.position.x = carousel.camHome.x;
          camera.position.y = carousel.camHome.y;
          camera.position.z = carousel.camHome.z;
          camera.lookAt(0, carousel.camHome.y, 0);
        }
      }

      // Reset carousel state
      carousel.mode = 'view';
      carousel.mixers = [];          // only drive the committed model's mixer via currentMixer
      carousel.dragOffset = 0;
      carousel.animFrom = 0;
      carousel.animTo = 0;
      carousel.animT = 1;

      // Add inside exitCarousel(), near the end before hiding controls:
      {
        const L = scene.userData?.lights, LV = scene.userData?.lightLevels;
        if (L && LV) {
          L.hemi.intensity = LV.hemi;
          L.key.intensity  = LV.key;
          L.fill.intensity = LV.fill;
          L.rim.intensity  = LV.rim;
        }
      }

      // Hide any selector UI (if visible)
      window.hideCharacterControls();
    }


  // Preload all models into carousel.cache
  function preloadAll() {
    const cfgs = window.characterConfigs || [];
    const jobs = [];
    for (let i = 0; i < cfgs.length; i++) {
      if (!carousel.cache[i]) {
        jobs.push(loadEntry(i));
      }
    }
    return Promise.all(jobs);
  }

    function loadEntry(index) {
      const cfg = window.characterConfigs[index];
      if (!cfg) return Promise.resolve();

      return new Promise((resolve, reject) => {
        gltfLoader.load(
          cfg.url,
          (gltf) => {
            const root = gltf.scene || gltf.scenes?.[0];
            if (!root) { resolve(); return; }

            const targetHeight = cfg.targetHeight ?? 1.4;

            // Center/scale
            centerAndScaleToHeight(root, targetHeight);
            if (cfg.scaleMul) root.scale.multiplyScalar(cfg.scaleMul);

            // Apply per-character Y offset ONCE and cache stable baseY
            root.userData = root.userData || {};
            if (cfg.y != null && !root.userData.yApplied) {
              root.position.y += cfg.y;
              root.userData.yApplied = true;
            }
            root.userData.baseY = root.position.y;

            // Mesh setup (single traverse)
            root.traverse(o => {
              if (o.isMesh) {
                o.castShadow = true;
                o.receiveShadow = true;
                o.raycast = THREE.Mesh.prototype.raycast; // robust raycast
                o.frustumCulled = false;     
                const store = (m) => {
                    if (!m) return;
                      m.userData = m.userData || {};
                      if ('emissive' in m && !m.userData._origEmissive) {
                        m.userData._origEmissive = m.emissive.clone();
                      }
                    };
                    if (Array.isArray(o.material)) o.material.forEach(store); else store(o.material);// avoid cull-related miss clicks
              }
            });

            root.updateMatrixWorld(true);

            // Animation
            let mixer = null;
            if (gltf.animations && gltf.animations.length) {
              mixer = new THREE.AnimationMixer(root);
              const clips = gltf.animations;
              const baseClip =
                THREE.AnimationClip.findByName(clips, 'Idle') ||
                THREE.AnimationClip.findByName(clips, 'idle') ||
                clips[0];

              const trimStart = Math.max(0, cfg.trimStart ?? 1.5);
              const trimEnd   = Math.max(0, cfg.trimEnd   ?? 2.0);
              const minDur = 0.05;
              const startSec = Math.min(trimStart, Math.max(0, baseClip.duration - minDur));
              const endSec   = Math.max(baseClip.duration - trimEnd, startSec + minDur);
              const fps = 30;
              const startFrame = Math.max(0, Math.floor(startSec * fps));
              const endFrame   = Math.max(startFrame + 1, Math.ceil(endSec * fps));
              const sub = THREE.AnimationUtils.subclip(
                baseClip, (baseClip.name || 'clip') + '_trim', startFrame, endFrame, fps
              );

              const action = mixer.clipAction(sub);
              action.setLoop(THREE.LoopPingPong, Infinity).reset().setEffectiveWeight(1).play();
              action.time = 1/60;
              mixer.update(0);
            }

            root.visible = false; // only shown in carousel or when committed

            // Store baseY on the cache entry so layout uses a stable Y
            const baseY = root.userData.baseY;
            carousel.cache[index] = { root, mixer, targetHeight, cfg, baseY };

            resolve();
          },
          undefined,
          reject
        );
      });
    }


  function startCarouselAnimations() {
    carousel.mixers = [];
    for (let i = 0; i < carousel.cache.length; i++) {
      const m = carousel.cache[i]?.mixer;
      if (m) carousel.mixers.push(m);
    }
  }

  // Pointer input for carousel
  let _downHandler, _moveHandler, _upHandler, _clickPreventUntil = 0;

  function attachCarouselInput() {
    const dom = renderer.domElement;
    const W = () => window.innerWidth;
    const thresholdPx = 50;
    carousel.dragSign = 1; // +1 desktop/mouse, -1 touch/mobile

    _downHandler = (e) => {
      const x = (e.touches ? e.touches[0].clientX : e.clientX);
      carousel.dragging = true;
      carousel.startX = x;
      carousel.dx = 0;
      carousel.dragSign = e.touches ? -1 : 1;
    };

    _moveHandler = (e) => {
      if (!carousel.dragging) return;
      const x = (e.touches ? e.touches[0].clientX : e.clientX);
      carousel.dx = x - carousel.startX;

      // Map pixels → "items" for consistent feel across sizes
      const itemsPerScreen = 1.5; // increase for more sensitivity
      const offset = (carousel.dx / W()) * itemsPerScreen * (carousel.dragSign || 1);
      setGroupOffset(offset);
    };

    _upHandler = () => {
      if (!carousel.dragging) return;
      const dx = carousel.dx;
      carousel.dragging = false;

      if (Math.abs(dx) > thresholdPx) {
          const dir = Math.sign(dx * (carousel.dragSign || 1));
        snapToIndex(carousel.activeIndex - dir);
        _clickPreventUntil = performance.now() + 250; // avoid accidental click-through
      } else {
        // light snap back
        snapToIndex(carousel.activeIndex);
      }
    };

    // Mouse
    dom.addEventListener('mousedown', _downHandler);
    window.addEventListener('mousemove', _moveHandler);
    window.addEventListener('mouseup', _upHandler);

    // Touch
    dom.addEventListener('touchstart', _downHandler, { passive: true });
    dom.addEventListener('touchmove', _moveHandler, { passive: true });
    dom.addEventListener('touchend', _upHandler, { passive: true });

    // (Optional) show UI label if you still use it
    document.getElementById('characterControls')?.classList.add('show');
    window.updateCharacterInfo?.();
  }


  function detachCarouselInput() {
    const dom = renderer.domElement;
    if (_downHandler) {
      dom.removeEventListener('mousedown', _downHandler);
      window.removeEventListener('mousemove', _moveHandler);
      window.removeEventListener('mouseup', _upHandler);
      dom.removeEventListener('touchstart', _downHandler);
      dom.removeEventListener('touchmove', _moveHandler);
      dom.removeEventListener('touchend', _upHandler);
    }
    _downHandler = _moveHandler = _upHandler = null;
  }

    function setGroupOffset(offsetInItems) {
      carousel.dragOffset = offsetInItems;
      layoutCarousel(offsetInItems);

      const n = (window.characterConfigs?.length || 1);
      const nearest = Math.round(carousel.activeIndex - offsetInItems);
      const wrapped = wrapIndex(nearest, n);

      if (wrapped !== window.currentCharacterIndex) {
        window.currentCharacterIndex = wrapped;   // updates the label
        carousel.activeIndex = wrapped;           // updates the model selection
        layoutCarousel(offsetInItems);            // re-layout so the model switches now
        window.updateCharacterInfo?.();           // refresh any UI text
      }
    }

    function onSwipeEnd() {
      if (carousel.mode !== 'carousel') return;
      if (!carousel.dragging) return;
      const n = (window.characterConfigs?.length || 1);
      const nearest = Math.round(carousel.activeIndex - (carousel.dragOffset || 0));
      const wrapped = wrapIndex(nearest, n);
      snapToIndex(wrapped);          // animate to final resting spot (shortest arc)
      carousel.dragOffset = 0;    
      carousel.dragging = false; // clear live drag
    }

    // Attach once, wherever you wire up input:
    window.addEventListener('pointerup', onSwipeEnd);
    window.addEventListener('touchend', onSwipeEnd);



  function nearestIndex() {
    let idx = carousel.activeIndex, best = 1e9;
    for (let i = 0; i < carousel.cache.length; i++) {
      const x = carousel.cache[i]?.root.position.x ?? 0;
      const d = Math.abs(x);
      if (d < best) { best = d; idx = i; }
    }
    return THREE.MathUtils.clamp(idx, 0, (window.characterConfigs?.length || 1) - 1);
  }
    
    function wrapIndex(i, n) { return ((i % n) + n) % n; }
    
    function ringDelta(a, b, n) {  // shortest signed steps from a → b
      let d = ((b - a) % n + n) % n;
      if (d > n / 2) d -= n;
      return d;
    }


    function snapToIndex(nextIndex) {
      const n = (window.characterConfigs?.length || 1);
      nextIndex = wrapIndex(nextIndex, n);

      // If we’re already animating, ignore this snap to prevent double-hops
      if (carousel.animT < 1) return;

      const from = carousel.activeIndex;
      const deltaItems = ringDelta(from, nextIndex, n) - (carousel.dragOffset || 0);

      carousel.animFrom  = carousel.dragOffset || 0;
      carousel.animTo    = carousel.animFrom + deltaItems;
      carousel.animT     = 0;
      carousel.animDur   = 500;
      carousel.animStart = performance.now();

      // Defer committing the new center until the tween completes
      carousel.pendingIndex = nextIndex;

      // UI can update the name immediately (optional)
      window.currentCharacterIndex = nextIndex;
      window.updateCharacterInfo?.();
    }



  // Free GPU memory when swapping models
  function disposeObject(obj) {
    obj?.traverse?.((node) => {
      if (node.isMesh) {
        node.geometry?.dispose?.();
        const mat = node.material;
        if (Array.isArray(mat)) {
          mat.forEach(m => { m.map?.dispose?.(); m.normalMap?.dispose?.(); m.roughnessMap?.dispose?.(); m.metalnessMap?.dispose?.(); m.emissiveMap?.dispose?.(); m.dispose?.(); });
        } else if (mat) {
          mat.map?.dispose?.(); mat.normalMap?.dispose?.(); mat.roughnessMap?.dispose?.(); mat.metalnessMap?.dispose?.(); mat.emissiveMap?.dispose?.(); mat.dispose?.();
        }
      }
    });
  }

  // ===== Three.js Setup =====
  function initThreeJS() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    window.scene = scene;

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);
    window.camera = camera;
    camera.layers.enable(1);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;

    const container = document.getElementById('scene-container');
    container.innerHTML = '';
    container.appendChild(renderer.domElement);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x1a1a2a, 0.7); scene.add(hemi);
    const key = new THREE.DirectionalLight(0xffffff, 1); key.position.set(5, 8, 6); key.castShadow = true; key.shadow.mapSize.set(2048,2048); key.shadow.camera.near=0.1; key.shadow.camera.far=50; scene.add(key);
    const fill = new THREE.DirectionalLight(0xffffff, 0.5); fill.position.set(-4, 5, 6); scene.add(fill);
    const rim  = new THREE.DirectionalLight(0x88aaff, 0.5); rim.position.set(-5, 2, -6); scene.add(rim);
    // In initThreeJS(), after you create hemi/key/fill/rim:
    scene.userData.lights = { hemi, key, fill, rim };
    scene.userData.lightLevels = {
      hemi: hemi.intensity, key: key.intensity, fill: fill.intensity, rim: rim.intensity
    };

    // Raycasting
    raycaster = new THREE.Raycaster();
    mouseNDC = new THREE.Vector2();

    // Events
    renderer.domElement.addEventListener('click', onCanvasClick);
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('mousemove', onMouseMove);

    setFixedTitleWidth("Super Maramu 2000");
  }

  function animate() {
    requestAnimationFrame(animate);
    tickAnimations();
    updateCarouselTween();
    renderer.render(scene, camera);
  }

    function onCanvasClick(e) {
      // Ignore clicks right after a swipe gesture to prevent accidental commits
      if (typeof _clickPreventUntil !== 'undefined' && performance.now() < _clickPreventUntil) return;

      // If we're already in carousel mode: a tap commits the centered character (if unlocked)
      if (carousel && carousel.mode === 'carousel') {
        const cfg = window.characterConfigs?.[window.currentCharacterIndex];
        if (cfg && cfg.status !== 'Locked') exitCarousel(true);
        return;
      }

      // Hit-test current character root
      const root = currentModel || window.character;
      if (!root || !camera || !renderer) return;

      // Ensure transforms are up to date before raycasting
      root.updateMatrixWorld(true);

      const rect = renderer.domElement.getBoundingClientRect();
      const ndc = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );

      raycaster.setFromCamera(ndc, camera);

      // ✅ robust: intersect the root recursively (covers all meshes/skins)
      const hits = raycaster.intersectObject(root, true);
      if (hits.length > 0) {
        window.onCharacterClick(); // enter carousel
        return;
      }

      // --- Fallback: screen-space AABB check (for odd exporters/materials) ---
      const box = new THREE.Box3().setFromObject(root);
      if (!box.isEmpty()) {
        const corners = [
          new THREE.Vector3(box.min.x, box.min.y, box.min.z),
          new THREE.Vector3(box.min.x, box.max.y, box.min.z),
          new THREE.Vector3(box.max.x, box.min.y, box.min.z),
          new THREE.Vector3(box.max.x, box.max.y, box.min.z),
          new THREE.Vector3(box.min.x, box.min.y, box.max.z),
          new THREE.Vector3(box.min.x, box.max.y, box.max.z),
          new THREE.Vector3(box.max.x, box.min.y, box.max.z),
          new THREE.Vector3(box.max.x, box.max.y, box.max.z),
        ];
        let minX =  Infinity, minY =  Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const v of corners) {
          v.project(camera);
          const sx = (v.x * 0.5 + 0.5) * rect.width  + rect.left;
          const sy = (-v.y * 0.5 + 0.5) * rect.height + rect.top;
          minX = Math.min(minX, sx); maxX = Math.max(maxX, sx);
          minY = Math.min(minY, sy); maxY = Math.max(maxY, sy);
        }
        if (e.clientX >= minX && e.clientX <= maxX && e.clientY >= minY && e.clientY <= maxY) {
          window.onCharacterClick(); // enter carousel
        }
      }
    }




  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onMouseMove(e) {
    mouseNDC.x =  (e.clientX / window.innerWidth)  * 2 - 1;
    mouseNDC.y = -(e.clientY / window.innerHeight) * 2 + 1;
    if (carousel.mode === 'carousel') return; // no hover highlight while carousel open
    checkHover();
  }

  function selectorOpen() {
    return !!document.getElementById('characterControls')?.classList.contains('show');
  }

  function checkHover() {
    if (!window.character) return;
    if (selectorOpen()) {
      if (lastHoverState) { setCharacterHighlight(false); lastHoverState = false; }
      return;
    }
    raycaster.setFromCamera(mouseNDC, camera);
    const intersects = raycaster.intersectObjects(window.character.children, true);
    hoverActive = intersects.length > 0;
    if (hoverActive !== lastHoverState) { setCharacterHighlight(hoverActive); lastHoverState = hoverActive; }
  }

  function setCharacterHighlight(active) {
    if (!window.scene || !window.character) return;
    if (active) {
      if (!hoverLight) {
        hoverLight = new THREE.PointLight(0x88aaff, 0.35, 3, 2);
        hoverLight.castShadow = false;
        hoverLight.position.set(0, 1.2, 1.6);
        window.character.add(hoverLight);
      }
    } else {
      if (hoverLight) { hoverLight.parent?.remove(hoverLight); hoverLight = null; }
      window.character.traverse(obj => {
           if (!obj.isMesh || !obj.material) return;
           const restore = (m) => {
             if (!m) return;
             if ('emissive' in m) {
               const orig = m.userData && m.userData._origEmissive;
               if (orig) m.emissive.copy(orig);
             }
           };
           if (Array.isArray(obj.material)) obj.material.forEach(restore); else restore(obj.material);
         });
    }
  }

  function setFixedTitleWidth(ghostString) {
    const nameEl = document.getElementById('characterName');
    if (!nameEl) return;
    const measurer = document.createElement('span');
    measurer.style.position = 'absolute';
    measurer.style.visibility = 'hidden';
    measurer.style.whiteSpace = 'nowrap';
    measurer.style.fontFamily = getComputedStyle(nameEl).fontFamily;
    measurer.style.fontSize = getComputedStyle(nameEl).fontSize;
    measurer.style.fontWeight = getComputedStyle(nameEl).fontWeight;
    measurer.textContent = ghostString;
    document.body.appendChild(measurer);
    const width = Math.ceil(measurer.getBoundingClientRect().width);
    document.body.removeChild(measurer);
    document.documentElement.style.setProperty('--title-width', width + 'px');
    const info = document.querySelector('.character-info'); if (info) { void getComputedStyle(info).width; }
  }

  // ===== UI bits (unchanged) =====
  function toggleMenu() { document.getElementById('menuTray').classList.toggle('open'); }
  function handleLogin() { document.getElementById('loginModal').classList.add('show'); }
  function closeLoginModal() { document.getElementById('loginModal').classList.remove('show'); }
  function switchTab(tab) {
    const tabs = document.querySelectorAll('.modal-tab');
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    tabs.forEach(t => t.classList.remove('active'));
    if (tab === 'login') { tabs[0].classList.add('active'); loginForm.style.display = 'block'; signupForm.style.display = 'none'; }
    else { tabs[1].classList.add('active'); loginForm.style.display = 'none'; signupForm.style.display = 'block'; }
  }

  document.addEventListener('click', function(e) {
    const tray = document.getElementById('menuTray');
    const btn = document.querySelector('.menu-button');
    if (tray && !tray.contains(e.target) && !btn.contains(e.target)) tray.classList.remove('open');
  });
  document.getElementById('loginModal').addEventListener('click', function(e) { if (e.target === this) closeLoginModal(); });

 /* function handleKeyPress(e) { if (e.key === 'Enter') sendMessage(); }
  function sendMessage() {
    const input = document.getElementById('chatInput');
    const text = input.value.trim();
    if (!text) return;
    addMessage(text, 'user');
    input.value = '';
    setTimeout(() => addMessage(generateBotResponse(text), 'bot'), 500);
  }
  function addMessage(text, sender) {
    const box = document.getElementById('chatMessages');
    if (!box) return;
    const div = document.createElement('div');
    div.className = `message ${sender}`;
    div.textContent = text;
    box.appendChild(div);
    box.scrollTop = box.scrollHeight;
  }
  function generateBotResponse(msg) {
    const m = msg.toLowerCase();
    if (m.includes('hello')) return "Hello! Welcome to the character showcase. How can I help you today?";
    if (m.includes('hi')) return "Hi there! I'm here to help you navigate the site. What would you like to know?";
    if (m.includes('help')) return "I can help you with information about the character, navigation, or features of this site.";
    if (m.includes('character')) return "This is a 3D character model you can click to open the selector.";
    if (m.includes('website')) return "This website showcases 3D character models with interactive features.";
    if (m.includes('menu')) return "Click the three dots in the top-left to open the menu.";
    if (m.includes('login')) return "Click the user icon in the top-right to open login.";
    return "Thanks for your message! Ask about the character, website features, or navigation.";
  }

  const chatEl = document.querySelector('.chatbot-container');
  const chatToggleBtn = document.getElementById('chatToggle');
  function setChatOpen(open) { chatEl.classList.toggle('open', open); chatToggleBtn.setAttribute('aria-expanded', String(open)); }
  setChatOpen(false);
  chatToggleBtn.addEventListener('click', () => { setChatOpen(!chatEl.classList.contains('open')); });*/

  // ===== Start =====
  window.addEventListener('load', () => {
    if (typeof THREE === 'undefined') { console.error('Three.js not loaded'); return; }
    initLoaders();
    initThreeJS();
    createCharacter();   // keep your initial single model
    animate();
    document.getElementById('prevArrow')?.addEventListener('click', window.previousCharacter);
    document.getElementById('nextArrow')?.addEventListener('click', window.nextCharacter);
  });

    window.addEventListener('keydown', (e) => {
      if (carousel.mode !== 'carousel') return;
      if (e.key === 'ArrowLeft')  snapToIndex(carousel.activeIndex - 1);
      if (e.key === 'ArrowRight') snapToIndex(carousel.activeIndex + 1);
    });
    
  // ===== Mobile zoom suppression (unchanged) =====
  (function () {
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (e) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });
  })();
  document.addEventListener('gesturestart',  e => e.preventDefault(), { passive: false });
  document.addEventListener('gesturechange', e => e.preventDefault(), { passive: false });
  document.addEventListener('gestureend',    e => e.preventDefault(), { passive: false });
  document.addEventListener('touchstart', function (e) { if (e.touches && e.touches.length > 1) e.preventDefault(); }, { passive: false });
  document.addEventListener('touchmove', function (e) { if (typeof e.scale === 'number' && e.scale !== 1) e.preventDefault(); }, { passive: false });

</script>

</body>
</html>
