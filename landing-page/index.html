<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LandingPage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script>
    // Safe to expose in client
    window.__SUPABASE_URL = 'https://srdwkfjterotzjwzoauj.supabase.co';
    window.__SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNyZHdrZmp0ZXJvdHpqd3pvYXVqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU4NjU5NTksImV4cCI6MjA3MTQ0MTk1OX0.c0mJbQsfJMmqLiulXdZfWscd7J507buzRXkd700ymAQ';
  </script>
  <script>
    window.supa = window.supabase.createClient(
      window.__SUPABASE_URL,
      window.__SUPABASE_ANON_KEY
    );
  </script>
  <script>
    (async function () {
      try {
        if (window.supa && location.hash && location.hash.includes('access_token')) {
          const params = new URLSearchParams(location.hash.slice(1));
          const access_token = params.get('access_token');
          const refresh_token = params.get('refresh_token');
          const error = params.get('error');
          const error_description = params.get('error_description');
          if (error) {
            alert(`Authentication error: ${error_description || error}`);
            history.replaceState({}, '', location.pathname + location.search);
            return;
          }
          if (access_token && refresh_token) {
            const { error } = await window.supa.auth.setSession({ access_token, refresh_token });
            if (error) alert(`Session error: ${error.message}`); else window.location.reload();
          }
          history.replaceState({}, '', location.pathname + location.search);
        }
      } catch (e) { console.error('[supabase] Magic link processing failed:', e); }
    })();
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #000; color: #fff;
      touch-action: none;
      -ms-touch-action: none;
    }

    .container { width: 100vw; height: 100vh; position: relative; }
    #scene-container { position: absolute; inset: 0; z-index: 1; }
    #scene-container canvas { display: block; cursor: pointer; }

    /* Top navigation */
    .top-nav {
      position: fixed; top: 0; left: 0; right: 0; z-index: 100;
      display: flex; justify-content: space-between; align-items: center; padding: 20px;
    }
    .menu-button, .login-button {
      width: 30px; height: 30px;
      background: #000;
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 50%;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: border-color .2s ease, background .2s ease;
    }
    .menu-button:hover, .login-button:hover { border-color: rgba(255, 255, 255, 0.45); }
    .menu-dots { display: flex; gap: 4px; }
    .dot { width: 3px; height: 3px; background: #fff; border-radius: 50%; }
    .user-icon { width: 16px; height: 16px; color: #fff; }
    .user-icon svg { width: 100%; height: 100%; fill: currentColor; }

    /* Menu tray */
    .menu-tray {
      position: fixed; top: 60px; left: 20px; width: 130px;
      background: rgba(0, 0, 0, 1); backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; z-index: 200;
      transform: translateY(-20px); opacity: 0; visibility: hidden; transition: all .3s ease; padding: 10px 0;
    }
    .menu-tray.open { transform: translateY(0); opacity: 1; visibility: visible; }

    .menu-item { position: relative; display: block; width: 100%; padding: 6px 15px; color: #fff; text-decoration: none; font-size: 14px; font-weight: 300; cursor: pointer; background: none; border: 0; }
    .menu-item::before { content: ""; position: absolute; inset: 1px; left: 8px; right: 8px; border-radius: 8px; background: rgba(255,255,255,0.12); opacity: 0; transform: scaleY(0.96); transition: opacity .15s ease, transform .2s ease; pointer-events: none; }
    .menu-item:hover::before, .menu-item:focus-visible::before { opacity: 1; transform: scaleY(1); }
    .menu-item, .menu-item * { position: relative; z-index: 1; }
    .menu-item .menu-pill { background: transparent !important; padding: 0 !important; border-radius: 0 !important; }

    /* Modal */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 300; display: none; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
    .modal-overlay.show { display: flex; }
    .login-modal { background: rgba(0,0,0,0.9); backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.2); border-radius: 16px; padding: 15px; width: 90%; max-width: 400px; position: relative; color: #fff; }
    .modal-close { position: absolute; top: 8px; right: 15px; background: none; border: none; color: rgba(255,255,255,0.6); font-size: 24px; cursor: button; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all .2s ease; }
    input, textarea, select { font-size: 16px; }
    button, a, .menu-button, .login-button, .chat-toggle, .send-button, .arrow-btn, .character-confirm { touch-action: manipulation; }
    .modal-close:hover { color: #fff; }
    .modal-tabs { display: flex; gap: 20px; margin-bottom: 20px; justify-content: center; }
    .modal-tab { background: none; border: none; color: rgba(255,255,255,0.6); font-size: 16px; padding: 8px 0; cursor: pointer; border-bottom: 2px solid transparent; transition: all .2s ease; }
    .modal-tab.active { color: #fff; }
    .form-group { margin-bottom: 12px; }
    .form-input { width: 100%; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; padding: 12px 15px; color: #fff; font-size: 16px; outline: none; }
    .form-input::placeholder { color: rgba(255,255,255,0.5); }
    .form-button { width: 100%; background: rgba(255,255,255,0.92); color: #000; border: none; border-radius: 8px; padding: 12px; font-size: 14px; font-weight: 500; cursor: pointer; }

    /* Character selector overlay */
    .character-controls { position: fixed; left: 50%; bottom: 8vh; transform: translateX(-50%); z-index: 250; opacity: 0; pointer-events: none; transition: opacity .2s ease; }
    .character-controls.show { opacity: 1; pointer-events: auto; }
    .character-info { display: grid; grid-template-rows: auto auto; gap: 8px; justify-items: center; min-width: 260px; }
    .character-header { display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 10px; }
    .character-name { text-align: center; font: 600 14px/1 system-ui, Arial, sans-serif; background: none; padding: .35rem .6rem; border-radius: .5rem; min-width: var(--title-width, 200px); }
    .arrow-btn { background: none; border: none; color: #fff; width: 28px; height: 28px; text-align: center; font-size: 18px; line-height: 26px; cursor: pointer; }
    .character-actions { display: flex; justify-content: center; }
    .character-confirm { background: rgba(255,255,255,.92); color: #000; border-radius: 8px; padding: 8px 16px; border: none; cursor: pointer; font-weight: 600; pointer-events: auto;
        z-index: 9999; touch-action: manipulation; }
    

  </style>
</head>
<body>

<div class="container">
  <div id="scene-container"></div>

  <!-- Top Navigation -->
  <div class="top-nav">
    <button class="menu-button" onclick="toggleMenu()">
      <div class="menu-dots"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
    </button>
    <button class="login-button" onclick="handleLogin()">
      <div class="user-icon">
        <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
      </div>
    </button>
  </div>

  <!-- Menu Tray -->
  <div class="menu-tray" id="menuTray">
    <a href="/landing-page/" class="menu-item"><span class="menu-pill">Home</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Label</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Merch</span></a>
    <a href="/packs/" class="menu-item"><span class="menu-pill">Packs</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Inventory</span></a>
  </div>

  <!-- Character Selector -->
  <div class="character-controls" id="characterControls">
    <div class="character-info">
      <div class="character-header">
        <button class="arrow-btn" id="prevArrow" title="Previous">‹</button>
        <div class="character-name" id="characterName">Default Character</div>
        <button class="arrow-btn" id="nextArrow" title="Next">›</button>
      </div>
      <div class="character-actions">
        <button class="character-confirm" onclick="window.confirmCharacter()">Select</button>
      </div>
    </div>
  </div>

  <!-- Login Modal -->
  <div class="modal-overlay" id="loginModal">
    <div class="login-modal">
      <button class="modal-close" onclick="closeLoginModal()">&times;</button>
      <div class="modal-tabs">
        <button class="modal-tab active" onclick="switchTab('login')">Account</button>
      </div>
      <div id="loginForm">
        <div class="form-group">
          <input type="email" id="loginEmail" class="form-input" placeholder="Email" required>
        </div>
        <button id="loginSubmit" class="form-button">Create / Login</button>
      </div>
      <div id="signupForm" style="display:none;">
        <div class="form-group"><input type="text" class="form-input" placeholder="Username"></div>
        <div class="form-group"><input type="email" class="form-input" placeholder="Email"></div>
        <button class="form-button">Sign Up</button>
      </div>
    </div>
  </div>
</div>

<script>
  // ===== Globals =====
  let scene, camera, renderer;
  let raycaster, mouseNDC, hoverActive = false, lastHoverState = false, hoverLight = null;
  let gltfLoader, dracoLoader;
  let currentModel = null, currentMixer = null, loadVersion = 0;
  const clock = new THREE.Clock();
  let preloadedModels = {};
  let isPreloading = false;

  // [CAROUSEL] state
  const carousel = {
    mode: 'view',
   /* group: null,
    spacing: 1.8,
    dragging: false,
    startX: 0,
    lastX: 0,        // NEW
    totalDelta: 0,   // NEW
    activeIndex: 0,
    mixers: [],
    cache: [],
    radius: 3,
    anglePer: Math.PI / 9.5,
    camHome: null,
    dragOffset: 0,
    animFrom: 0,
    animTo: 0,
    animT: 1,
    animDur: 300,
    animStart: 0,
    isAnimating: false,  // NEW
    lastUpdateTime: 0    // NEW*/
  };
    
    // Carousel layout + tween parameters (safe at top-level)
    /*carousel.radius     = 3;
    carousel.anglePer   = Math.PI / 9.5;
    carousel.camHome    = null;        // set on first enterCarousel()
    carousel.dragOffset = 0;
    carousel.animFrom   = 0;
    carousel.animTo     = 0;
    carousel.animT      = 1;
    carousel.animDur    = 300;
    carousel.animStart  = 0;*/


  // expose for other code
  window.scene = null; window.camera = null; window.renderer = null; window.character = null;
  window.currentCharacterIndex = 0;

  function initLoaders() {
    gltfLoader = new THREE.GLTFLoader();
    dracoLoader = new THREE.DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
    gltfLoader.setDRACOLoader(dracoLoader);
  }

  window.characterConfigs = [
    { name: "Sloucho", status: "Unlocked", url: "/assets/models/sloucho.glb", targetHeight: 1.4, y: 0.02, scaleMul: 0.6, trimStart: 1.5, trimEnd: 2.0 },
    { name: "Rás",     status: "Unlocked", url: "/assets/models/ras.glb",     targetHeight: 1.4, y: 0.05, scaleMul: 0.6, trimStart: 0.12, trimEnd: 0.10 },
    { name: "Super Maramu 2000", status: "Unlocked", url: "/assets/models/maramu.glb", targetHeight: 1.4, y: -0.15, scaleMul: 0.5, trimStart: 0.12, trimEnd: 0.10 }
  ];
  
  // Add after your characterConfigs
  let preloadedModels = {};
  let isPreloading = false;

  function preloadAllModels() {
    if (isPreloading) return;
    isPreloading = true;
    
    const promises = window.characterConfigs.map((cfg, index) => {
      return new Promise((resolve) => {
        gltfLoader.load(
          cfg.url,
          (gltf) => {
            const root = gltf.scene || gltf.scenes?.[0];
            if (root) {
              // Process the model but don't add to scene yet
              const targetHeight = cfg.targetHeight ?? 1.8;
              centerAndScaleToHeight(root, targetHeight);
              if (cfg.scaleMul) root.scale.multiplyScalar(cfg.scaleMul);
              
              root.userData = root.userData || {};
              if (cfg.y != null && !root.userData.yApplied) {
                root.position.y += cfg.y;
                root.userData.yApplied = true;
              }
              root.userData.baseY = root.position.y;
              
              // Setup materials and raycast
              root.traverse((o) => {
                if (!o.isMesh) return;
                o.castShadow = true;
                o.receiveShadow = true;
                o.raycast = THREE.Mesh.prototype.raycast;
                o.frustumCulled = false;
                
                const store = (m) => {
                  if (!m) return;
                  m.userData = m.userData || {};
                  if ('emissive' in m && !m.userData._origEmissive) {
                    m.userData._origEmissive = m.emissive.clone();
                  }
                };
                if (Array.isArray(o.material)) {
                  o.material.forEach(store);
                } else {
                  store(o.material);
                }
              });
              
              // Setup animations
              let mixer = null;
              if (gltf.animations && gltf.animations.length) {
                mixer = new THREE.AnimationMixer(root);
                const clips = gltf.animations;
                const baseClip =
                  THREE.AnimationClip.findByName(clips, 'Idle') ||
                  THREE.AnimationClip.findByName(clips, 'idle') ||
                  clips[0];

                const trimStart = Math.max(0, cfg.trimStart ?? 1.5);
                const trimEnd = Math.max(0, cfg.trimEnd ?? 2.0);
                const minDur = 0.05;
                const startSec = Math.min(trimStart, Math.max(0, baseClip.duration - minDur));
                const endSec = Math.max(baseClip.duration - trimEnd, startSec + minDur);
                const fps = 30;
                const startFrame = Math.max(0, Math.floor(startSec * fps));
                const endFrame = Math.max(startFrame + 1, Math.ceil(endSec * fps));
                const sub = THREE.AnimationUtils.subclip(
                  baseClip,
                  (baseClip.name || 'clip') + '_trim',
                  startFrame, endFrame, fps
                );

                const action = mixer.clipAction(sub);
                action.setLoop(THREE.LoopPingPong, Infinity)
                      .reset()
                      .setEffectiveWeight(1)
                      .play();
                action.time = 1/60;
                mixer.update(0);
              }
              
              preloadedModels[index] = { root: root.clone(), mixer, cfg };
            }
            resolve();
          },
          undefined,
          () => resolve() // Continue even if one model fails
        );
      });
    });
    
    return Promise.all(promises);
  }

  function centerAndScaleToHeight(root, targetHeight = 1.8) {
    const box = new THREE.Box3().setFromObject(root);
    const size = new THREE.Vector3(); box.getSize(size);
    const center = new THREE.Vector3(); box.getCenter(center);
    root.position.sub(center);
    root.position.y += targetHeight * 0.5;
    const h = Math.max(size.y, 1e-6);
    const s = targetHeight / h;
    root.scale.multiplyScalar(s);
  }

  // Adjusted framing baseline (you previously used 0.2 center—keeping consistent)
  function frameCameraOnTargetHeight(camera, targetHeight = 1.8, pad = 1.4, centerYFactor = 0.2) {
    const fovRad = (camera.fov * Math.PI) / 180;
    const halfH  = (targetHeight * pad) / 2;
    const dist   = halfH / Math.tan(fovRad / 2);
    const cy = targetHeight * centerYFactor;
    camera.position.set(0, cy, dist);
    camera.lookAt(0, cy, 0);
    camera.updateProjectionMatrix();
  }

    function tickAnimations() {
      const dt = Math.min(clock.getDelta(), 0.033);
      if (currentMixer) currentMixer.update(dt);
      // Remove carousel mixer code since we're not using it
    }

  // ===== Character UI =====
  window.updateCharacterInfo = function() {
    const config = window.characterConfigs[window.currentCharacterIndex];
    const nameEl = document.getElementById('characterName');
    const confirmBtn = document.querySelector('.character-confirm');
    if (!config || !nameEl) return;
    nameEl.textContent = config.name;
    if (confirmBtn) {
      const locked = config.status === 'Locked';
      confirmBtn.disabled = locked;
      confirmBtn.style.opacity = locked ? '0.5' : '1';
      confirmBtn.textContent = locked ? 'Locked' : 'Select';
    }
  };

  // These still work in view mode; in carousel they snap between items.
  window.previousCharacter = function() {
    window.currentCharacterIndex = (window.currentCharacterIndex - 1 + window.characterConfigs.length) % window.characterConfigs.length;
    window.createCharacter?.();
    window.updateCharacterInfo();
  };

    window.nextCharacter = function() {
      window.currentCharacterIndex = (window.currentCharacterIndex + 1) % window.characterConfigs.length;
      window.createCharacter?.();
      window.updateCharacterInfo();
    };

  // Commit selection (closes carousel if open)
  window.confirmCharacter = function() {
    const cfg = window.characterConfigs[window.currentCharacterIndex];
    if (!cfg) return;
    if (carousel.mode === 'carousel') {
      if (cfg.status === 'Locked') return; // keep button disabled UI already
      exitCarousel(true); // commit
      return;
    }
    if (cfg.status === 'Unlocked') window.hideCharacterControls();
  };

  window.hideCharacterControls = function() {
    document.getElementById('characterControls')?.classList.remove('show');
    lastHoverState = null;
  };

  // Click on model → enter carousel
  window.onCharacterClick = function() {
    if (carousel.mode === 'view') enterCarousel();
  };

  // ===== Character Factory (existing single-model loader) =====
  window.createCharacter = function () {
    if (!window.scene) { console.error('Scene not ready'); return; }

    // Remove current model
    if (window.character && window.character !== currentModel) {
      try { scene.remove(window.character); } catch {}
      try { disposeObject(window.character); } catch {}
      window.character = null;
    }

    if (currentMixer) {
      try { currentMixer.stopAllAction(); } catch {}
      try { if (currentModel) currentMixer.uncacheRoot(currentModel); } catch {}
      currentMixer = null;
    }
    if (currentModel) { scene.remove(currentModel); disposeObject(currentModel); currentModel = null; }

    const idx = (window.currentCharacterIndex ?? 0) % (window.characterConfigs.length || 1);
    const preloaded = preloadedModels[idx];
    
    if (preloaded) {
      // Use preloaded model - instant switching!
      const root = preloaded.root.clone();
      const cfg = preloaded.cfg;
      
      // Create new mixer for this instance
      if (preloaded.mixer && preloaded.action) {
        currentMixer = new THREE.AnimationMixer(root);
        const action = currentMixer.clipAction(preloaded.action.getClip());
        action.setLoop(THREE.LoopPingPong, Infinity)
              .reset()
              .setEffectiveWeight(1)
              .play();
        action.time = 1/60;
        currentMixer.update(0);
      } else {
        currentMixer = null;
      }

      root.name = 'CHARACTER';
      scene.add(root);
      currentModel = root;
      window.character = root;

      frameCameraOnTargetHeight(camera, cfg.targetHeight ?? 1.4, 1.4, 0.2);
      window.updateCharacterInfo?.();
    } else {
      // Fallback to original loading method
      const cfg = window.characterConfigs[idx];
      if (!cfg || !cfg.url) return;

      const myVersion = ++loadVersion;
      gltfLoader.load(
        cfg.url,
        (gltf) => {
          if (myVersion !== loadVersion) { if (gltf.scene) disposeObject(gltf.scene); return; }
          const root = gltf.scene || gltf.scenes?.[0];
          if (!root) return;

          const targetHeight = cfg.targetHeight ?? 1.8;

          centerAndScaleToHeight(root, targetHeight);
          if (cfg.scaleMul) root.scale.multiplyScalar(cfg.scaleMul);

          root.userData = root.userData || {};
          if (cfg.y != null && !root.userData.yApplied) {
            root.position.y += cfg.y;
            root.userData.yApplied = true;
          }
          root.userData.baseY = root.position.y;

          root.traverse((o) => {
            if (!o.isMesh) return;
            o.castShadow = true;
            o.receiveShadow = true;
            o.raycast = THREE.Mesh.prototype.raycast;
            o.frustumCulled = false;

            const store = (m) => {
              if (!m) return;
              m.userData = m.userData || {};
              if ('emissive' in m && !m.userData._origEmissive) {
                m.userData._origEmissive = m.emissive.clone();
              }
            };
            if (Array.isArray(o.material)) {
              o.material.forEach(store);
            } else {
              store(o.material);
            }
          });

          root.updateMatrixWorld(true);

          if (gltf.animations && gltf.animations.length) {
            currentMixer = new THREE.AnimationMixer(root);
            const clips = gltf.animations;
            const baseClip =
              THREE.AnimationClip.findByName(clips, 'Idle') ||
              THREE.AnimationClip.findByName(clips, 'idle') ||
              clips[0];

            const trimStart = Math.max(0, cfg.trimStart ?? 1.5);
            const trimEnd = Math.max(0, cfg.trimEnd ?? 2.0);
            const minDur = 0.05;
            const startSec = Math.min(trimStart, Math.max(0, baseClip.duration - minDur));
            const endSec = Math.max(baseClip.duration - trimEnd, startSec + minDur);
            const fps = 30;
            const startFrame = Math.max(0, Math.floor(startSec * fps));
            const endFrame = Math.max(startFrame + 1, Math.ceil(endSec * fps));
            const sub = THREE.AnimationUtils.subclip(
              baseClip,
              (baseClip.name || 'clip') + '_trim',
              startFrame, endFrame, fps
            );

            const action = currentMixer.clipAction(sub);
            action.setLoop(THREE.LoopPingPong, Infinity)
                  .reset()
                  .setEffectiveWeight(1)
                  .play();
            action.time = 1/60;
            currentMixer.update(0);
          } else {
            currentMixer = null;
          }

          root.name = 'CHARACTER';
          scene.add(root);
          currentModel = root;
          window.character = root;

          frameCameraOnTargetHeight(camera, targetHeight, 1.4, 0.2);
          window.updateCharacterInfo?.();
        },
        undefined,
        (err) => console.error('GLB load error for', cfg.url, err)
      );
    }
  };



    // Drive easing each frame (call from your animate loop)
    function updateCarouselTween() {
      if (carousel.mode !== 'carousel') return;
      
      const now = performance.now();
      
      // Prevent too frequent updates
      if (now - carousel.lastUpdateTime < 16) return; // ~60fps limit
      carousel.lastUpdateTime = now;
      
      if (carousel.animT < 1 && carousel.isAnimating) {
        const t = Math.min(1, (now - carousel.animStart) / carousel.animDur);
        const u = t < 0.5
          ? 16 * t * t * t * t * t
          : 1 - Math.pow(-2 * t + 2, 5) / 2;
        
        const off = THREE.MathUtils.lerp(carousel.animFrom, carousel.animTo, u);
        layoutCarousel(off);
        carousel.animT = t;
        
        if (t === 1) {
          carousel.dragOffset = 0;
          carousel.isAnimating = false;
          if (typeof carousel.pendingIndex === 'number') {
            carousel.activeIndex = carousel.pendingIndex;
            carousel.pendingIndex = null;
            window.updateCharacterInfo?.();
          }
        }
      } else if (!carousel.isAnimating) {
        layoutCarousel(carousel.dragOffset || 0);
      }
    }

  // ===== Carousel implementation =====
  function enterCarousel() {
    const c = document.getElementById('characterControls');
    if (c) c.classList.add('show');
    
    // Just dim the lights, no complex group management
    const L = scene.userData?.lights, LV = scene.userData?.lightLevels;
    if (L && LV) {
      L.hemi.intensity = LV.hemi * 0.25;
      L.key.intensity = LV.key * 0.35;
      L.fill.intensity = LV.fill * 0.25;
      L.rim.intensity = LV.rim * 0.25;
    }
    
    carousel.mode = 'carousel';
    attachSimpleSwipeInput();
  }


    function exitCarousel(commitSelection) {
      detachSimpleSwipeInput();
      
      // Restore lights
      const L = scene.userData?.lights, LV = scene.userData?.lightLevels;
      if (L && LV) {
        L.hemi.intensity = LV.hemi;
        L.key.intensity = LV.key;
        L.fill.intensity = LV.fill;
        L.rim.intensity = LV.rim;
      }
      
      carousel.mode = 'view';
      window.hideCharacterControls();
    }


  // Preload all models into carousel.cache
  function preloadAll() {
    const cfgs = window.characterConfigs || [];
    const jobs = [];
    for (let i = 0; i < cfgs.length; i++) {
      if (!carousel.cache[i]) {
        jobs.push(loadEntry(i));
      }
    }
    return Promise.all(jobs);
  }

    function loadEntry(index) {
      const cfg = window.characterConfigs[index];
      if (!cfg) return Promise.resolve();

      return new Promise((resolve, reject) => {
        gltfLoader.load(
          cfg.url,
          (gltf) => {
            const root = gltf.scene || gltf.scenes?.[0];
            if (!root) { resolve(); return; }

            const targetHeight = cfg.targetHeight ?? 1.4;

            // Center/scale
            centerAndScaleToHeight(root, targetHeight);
            if (cfg.scaleMul) root.scale.multiplyScalar(cfg.scaleMul);

            // Apply per-character Y offset ONCE and cache stable baseY
            root.userData = root.userData || {};
            if (cfg.y != null && !root.userData.yApplied) {
              root.position.y += cfg.y;
              root.userData.yApplied = true;
            }
            root.userData.baseY = root.position.y;

            // Mesh setup (single traverse)
            root.traverse(o => {
              if (o.isMesh) {
                o.castShadow = true;
                o.receiveShadow = true;
                o.raycast = THREE.Mesh.prototype.raycast; // robust raycast
                o.frustumCulled = false;     
                const store = (m) => {
                    if (!m) return;
                      m.userData = m.userData || {};
                      if ('emissive' in m && !m.userData._origEmissive) {
                        m.userData._origEmissive = m.emissive.clone();
                      }
                    };
                    if (Array.isArray(o.material)) o.material.forEach(store); else store(o.material);// avoid cull-related miss clicks
              }
            });

            root.updateMatrixWorld(true);

            // Animation
            let mixer = null;
            if (gltf.animations && gltf.animations.length) {
              mixer = new THREE.AnimationMixer(root);
              const clips = gltf.animations;
              const baseClip =
                THREE.AnimationClip.findByName(clips, 'Idle') ||
                THREE.AnimationClip.findByName(clips, 'idle') ||
                clips[0];

              const trimStart = Math.max(0, cfg.trimStart ?? 1.5);
              const trimEnd   = Math.max(0, cfg.trimEnd   ?? 2.0);
              const minDur = 0.05;
              const startSec = Math.min(trimStart, Math.max(0, baseClip.duration - minDur));
              const endSec   = Math.max(baseClip.duration - trimEnd, startSec + minDur);
              const fps = 30;
              const startFrame = Math.max(0, Math.floor(startSec * fps));
              const endFrame   = Math.max(startFrame + 1, Math.ceil(endSec * fps));
              const sub = THREE.AnimationUtils.subclip(
                baseClip, (baseClip.name || 'clip') + '_trim', startFrame, endFrame, fps
              );

              const action = mixer.clipAction(sub);
              action.setLoop(THREE.LoopPingPong, Infinity).reset().setEffectiveWeight(1).play();
              action.time = 1/60;
              mixer.update(0);
            }

            root.visible = false; // only shown in carousel or when committed

            // Store baseY on the cache entry so layout uses a stable Y
            const baseY = root.userData.baseY;
            carousel.cache[index] = { root, mixer, targetHeight, cfg, baseY };

            resolve();
          },
          undefined,
          reject
        );
      });
    }


  function startCarouselAnimations() {
    carousel.mixers = [];
    for (let i = 0; i < carousel.cache.length; i++) {
      const m = carousel.cache[i]?.mixer;
      if (m) carousel.mixers.push(m);
    }
  }

  // Pointer input for carousel
  //let _downHandler, _moveHandler, _upHandler;
  let clickPreventUntil = 0;

  // COMPLETELY REWRITTEN mobile input handling
  let carouselInput = {
    active: false,
    startX: 0,
    lastX: 0,
    startTime: 0,
    velocity: 0,
    thresholdPx: 50,
    sensitivity: 1.5
  };

    let simpleSwipe = { active: false, startX: 0, threshold: 50 };

    function attachSimpleSwipeInput() {
      if (simpleSwipe.active) return;
      
      const dom = renderer.domElement;
      simpleSwipe.active = true;
      
      function onStart(e) {
        simpleSwipe.startX = e.touches ? e.touches[0].clientX : e.clientX;
      }
      
      function onEnd(e) {
        const endX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
        const deltaX = endX - simpleSwipe.startX;
        
        if (Math.abs(deltaX) > simpleSwipe.threshold) {
          if (deltaX > 0) {
            window.previousCharacter(); // Swipe right = previous
          } else {
            window.nextCharacter(); // Swipe left = next
          }
        }
      }
      
      dom.addEventListener('touchstart', onStart);
      dom.addEventListener('touchend', onEnd);
      dom.addEventListener('mousedown', onStart);
      dom.addEventListener('mouseup', onEnd);
      
      simpleSwipe.handlers = { onStart, onEnd, dom };
    }

    function detachSimpleSwipeInput() {
      if (!simpleSwipe.active || !simpleSwipe.handlers) return;
      
      const { onStart, onEnd, dom } = simpleSwipe.handlers;
      dom.removeEventListener('touchstart', onStart);
      dom.removeEventListener('touchend', onEnd);
      dom.removeEventListener('mousedown', onStart);
      dom.removeEventListener('mouseup', onEnd);
      
      simpleSwipe.active = false;
      simpleSwipe.handlers = null;
    }


  // Free GPU memory when swapping models
  function disposeObject(obj) {
    obj?.traverse?.((node) => {
      if (node.isMesh) {
        node.geometry?.dispose?.();
        const mat = node.material;
        if (Array.isArray(mat)) {
          mat.forEach(m => { m.map?.dispose?.(); m.normalMap?.dispose?.(); m.roughnessMap?.dispose?.(); m.metalnessMap?.dispose?.(); m.emissiveMap?.dispose?.(); m.dispose?.(); });
        } else if (mat) {
          mat.map?.dispose?.(); mat.normalMap?.dispose?.(); mat.roughnessMap?.dispose?.(); mat.metalnessMap?.dispose?.(); mat.emissiveMap?.dispose?.(); mat.dispose?.();
        }
      }
    });
  }

  // ===== Three.js Setup =====
  function initThreeJS() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    window.scene = scene;

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);
    window.camera = camera;
    camera.layers.enable(1);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;

    const container = document.getElementById('scene-container');
    container.innerHTML = '';
    container.appendChild(renderer.domElement);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x1a1a2a, 0.7); scene.add(hemi);
    const key = new THREE.DirectionalLight(0xffffff, 1); key.position.set(5, 8, 6); key.castShadow = true; key.shadow.mapSize.set(2048,2048); key.shadow.camera.near=0.1; key.shadow.camera.far=50; scene.add(key);
    const fill = new THREE.DirectionalLight(0xffffff, 0.5); fill.position.set(-4, 5, 6); scene.add(fill);
    const rim  = new THREE.DirectionalLight(0x88aaff, 0.5); rim.position.set(-5, 2, -6); scene.add(rim);
    // In initThreeJS(), after you create hemi/key/fill/rim:
    scene.userData.lights = { hemi, key, fill, rim };
    scene.userData.lightLevels = {
      hemi: hemi.intensity, key: key.intensity, fill: fill.intensity, rim: rim.intensity
    };

    // Raycasting
    raycaster = new THREE.Raycaster();
    mouseNDC = new THREE.Vector2();

    // Events
    renderer.domElement.addEventListener('click', onCanvasClick);
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('mousemove', onMouseMove);

    setFixedTitleWidth("Super Maramu 2000");
  }

    function animate() {
      requestAnimationFrame(animate);
      tickAnimations();
      // Remove updateCarouselTween() call
      renderer.render(scene, camera);
    }
    
    function onCanvasClick(e) {
      if (performance.now() < clickPreventUntil) return;  // Remove underscore

      // If we're already in carousel mode: a tap commits the centered character (if unlocked)
      if (carousel && carousel.mode === 'carousel') {
        const cfg = window.characterConfigs?.[window.currentCharacterIndex];
        if (cfg && cfg.status !== 'Locked') exitCarousel(true);
        return;
      }

      // Hit-test current character root
      const root = currentModel || window.character;
      if (!root || !camera || !renderer) return;

      // Ensure transforms are up to date before raycasting
      root.updateMatrixWorld(true);

      const rect = renderer.domElement.getBoundingClientRect();
      const ndc = new THREE.Vector2(
        ((e.clientX - rect.left) / rect.width) * 2 - 1,
        -((e.clientY - rect.top) / rect.height) * 2 + 1
      );

      raycaster.setFromCamera(ndc, camera);

      // ✅ robust: intersect the root recursively (covers all meshes/skins)
      const hits = raycaster.intersectObject(root, true);
      if (hits.length > 0) {
        window.onCharacterClick(); // enter carousel
        return;
      }

      // --- Fallback: screen-space AABB check (for odd exporters/materials) ---
      const box = new THREE.Box3().setFromObject(root);
      if (!box.isEmpty()) {
        const corners = [
          new THREE.Vector3(box.min.x, box.min.y, box.min.z),
          new THREE.Vector3(box.min.x, box.max.y, box.min.z),
          new THREE.Vector3(box.max.x, box.min.y, box.min.z),
          new THREE.Vector3(box.max.x, box.max.y, box.min.z),
          new THREE.Vector3(box.min.x, box.min.y, box.max.z),
          new THREE.Vector3(box.min.x, box.max.y, box.max.z),
          new THREE.Vector3(box.max.x, box.min.y, box.max.z),
          new THREE.Vector3(box.max.x, box.max.y, box.max.z),
        ];
        let minX =  Infinity, minY =  Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const v of corners) {
          v.project(camera);
          const sx = (v.x * 0.5 + 0.5) * rect.width  + rect.left;
          const sy = (-v.y * 0.5 + 0.5) * rect.height + rect.top;
          minX = Math.min(minX, sx); maxX = Math.max(maxX, sx);
          minY = Math.min(minY, sy); maxY = Math.max(maxY, sy);
        }
        if (e.clientX >= minX && e.clientX <= maxX && e.clientY >= minY && e.clientY <= maxY) {
          window.onCharacterClick(); // enter carousel
        }
      }
    }




  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onMouseMove(e) {
    mouseNDC.x =  (e.clientX / window.innerWidth)  * 2 - 1;
    mouseNDC.y = -(e.clientY / window.innerHeight) * 2 + 1;
    if (carousel.mode === 'carousel') return; // no hover highlight while carousel open
    checkHover();
  }

  function selectorOpen() {
    return !!document.getElementById('characterControls')?.classList.contains('show');
  }

  function checkHover() {
    if (!window.character) return;
    if (selectorOpen()) {
      if (lastHoverState) { setCharacterHighlight(false); lastHoverState = false; }
      return;
    }
    raycaster.setFromCamera(mouseNDC, camera);
    const intersects = raycaster.intersectObjects(window.character.children, true);
    hoverActive = intersects.length > 0;
    if (hoverActive !== lastHoverState) { setCharacterHighlight(hoverActive); lastHoverState = hoverActive; }
  }

  function setCharacterHighlight(active) {
    if (!window.scene || !window.character) return;
    if (active) {
      if (!hoverLight) {
        hoverLight = new THREE.PointLight(0x88aaff, 0.35, 3, 2);
        hoverLight.castShadow = false;
        hoverLight.position.set(0, 1.2, 1.6);
        window.character.add(hoverLight);
      }
    } else {
      if (hoverLight) { hoverLight.parent?.remove(hoverLight); hoverLight = null; }
      window.character.traverse(obj => {
           if (!obj.isMesh || !obj.material) return;
           const restore = (m) => {
             if (!m) return;
             if ('emissive' in m) {
               const orig = m.userData && m.userData._origEmissive;
               if (orig) m.emissive.copy(orig);
             }
           };
           if (Array.isArray(obj.material)) obj.material.forEach(restore); else restore(obj.material);
         });
    }
  }

  function setFixedTitleWidth(ghostString) {
    const nameEl = document.getElementById('characterName');
    if (!nameEl) return;
    const measurer = document.createElement('span');
    measurer.style.position = 'absolute';
    measurer.style.visibility = 'hidden';
    measurer.style.whiteSpace = 'nowrap';
    measurer.style.fontFamily = getComputedStyle(nameEl).fontFamily;
    measurer.style.fontSize = getComputedStyle(nameEl).fontSize;
    measurer.style.fontWeight = getComputedStyle(nameEl).fontWeight;
    measurer.textContent = ghostString;
    document.body.appendChild(measurer);
    const width = Math.ceil(measurer.getBoundingClientRect().width);
    document.body.removeChild(measurer);
    document.documentElement.style.setProperty('--title-width', width + 'px');
    const info = document.querySelector('.character-info'); if (info) { void getComputedStyle(info).width; }
  }

  // ===== UI bits (unchanged) =====
  function toggleMenu() { document.getElementById('menuTray').classList.toggle('open'); }
  function handleLogin() { document.getElementById('loginModal').classList.add('show'); }
  function closeLoginModal() { document.getElementById('loginModal').classList.remove('show'); }
  function switchTab(tab) {
    const tabs = document.querySelectorAll('.modal-tab');
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    tabs.forEach(t => t.classList.remove('active'));
    if (tab === 'login') { tabs[0].classList.add('active'); loginForm.style.display = 'block'; signupForm.style.display = 'none'; }
    else { tabs[1].classList.add('active'); loginForm.style.display = 'none'; signupForm.style.display = 'block'; }
  }

  document.addEventListener('click', function(e) {
    const tray = document.getElementById('menuTray');
    const btn = document.querySelector('.menu-button');
    if (tray && !tray.contains(e.target) && !btn.contains(e.target)) tray.classList.remove('open');
  });
  document.getElementById('loginModal').addEventListener('click', function(e) { if (e.target === this) closeLoginModal(); });


  // ===== Start =====
  window.addEventListener('load', () => {
    if (typeof THREE === 'undefined') { console.error('Three.js not loaded'); return; }
    initLoaders();
    initThreeJS();
    
    preloadAllModels().then(() => {
      console.log('All models preloaded');
    });
    
    createCharacter();   // keep your initial single model
    animate();
    document.getElementById('prevArrow')?.addEventListener('click', window.previousCharacter);
    document.getElementById('nextArrow')?.addEventListener('click', window.nextCharacter);
  });

    window.addEventListener('keydown', (e) => {
      if (carousel.mode !== 'carousel') return;
      if (e.key === 'ArrowLeft') window.previousCharacter();
      if (e.key === 'ArrowRight') window.nextCharacter();
    });
    
  // ===== Mobile zoom suppression (unchanged) =====
  (function () {
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (e) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });
  })();
  document.addEventListener('gesturestart',  e => e.preventDefault(), { passive: false });
  document.addEventListener('gesturechange', e => e.preventDefault(), { passive: false });
  document.addEventListener('gestureend',    e => e.preventDefault(), { passive: false });
  document.addEventListener('touchstart', function (e) { if (e.touches && e.touches.length > 1) e.preventDefault(); }, { passive: false });
  document.addEventListener('touchmove', function (e) { if (typeof e.scale === 'number' && e.scale !== 1) e.preventDefault(); }, { passive: false });

</script>

</body>
</html>
