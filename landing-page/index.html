<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>LandingPage</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

  <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
  <script>
    // Safe to expose in client
    window.__SUPABASE_URL = 'https://srdwkfjterotzjwzoauj.supabase.co';
    window.__SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNyZHdrZmp0ZXJvdHpqd3pvYXVqIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTU4NjU5NTksImV4cCI6MjA3MTQ0MTk1OX0.c0mJbQsfJMmqLiulXdZfWscd7J507buzRXkd700ymAQ';
  </script>
  <script>
    window.supa = window.supabase.createClient(
      window.__SUPABASE_URL,
      window.__SUPABASE_ANON_KEY
    );
  </script>
  <script>
    (async function () {
      try {
        if (window.supa && location.hash && location.hash.includes('access_token')) {
          const params = new URLSearchParams(location.hash.slice(1));
          const access_token = params.get('access_token');
          const refresh_token = params.get('refresh_token');
          const error = params.get('error');
          const error_description = params.get('error_description');
          if (error) {
            alert(`Authentication error: ${error_description || error}`);
            history.replaceState({}, '', location.pathname + location.search);
            return;
          }
          if (access_token && refresh_token) {
            const { error } = await window.supa.auth.setSession({ access_token, refresh_token });
            if (error) alert(`Session error: ${error.message}`); else window.location.reload();
          }
          history.replaceState({}, '', location.pathname + location.search);
        }
      } catch (e) { console.error('[supabase] Magic link processing failed:', e); }
    })();
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/DRACOLoader.js"></script>

  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      height: 100%;
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: #000; color: #fff;
      touch-action: none;
      -ms-touch-action: none;
    }

    .container { width: 100vw; height: 100vh; position: relative; }
    #scene-container { position: absolute; inset: 0; z-index: 1; }
    #scene-container canvas { display: block; cursor: pointer; }

    /* Loading indicator */
    .loading-indicator {
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      z-index: 500; color: #fff; text-align: center; font-size: 14px;
      background: rgba(0,0,0,0.8); padding: 20px; border-radius: 10px;
      backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);
      transition: opacity 0.3s ease;
    }
    .loading-progress {
      width: 200px; height: 4px; background: rgba(255,255,255,0.2);
      border-radius: 2px; margin: 10px 0; overflow: hidden;
    }
    .loading-bar {
      height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A);
      width: 0%; transition: width 0.3s ease; border-radius: 2px;
    }

    /* Top navigation */
    .top-nav {
      position: fixed; top: 0; left: 0; right: 0; z-index: 100;
      display: flex; justify-content: space-between; align-items: center; padding: 20px;
    }
    .menu-button, .login-button {
      width: 30px; height: 30px;
      background: #000;
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 50%;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
      transition: border-color .2s ease, background .2s ease;
    }
    .menu-button:hover, .login-button:hover { border-color: rgba(255, 255, 255, 0.45); }
    .menu-dots { display: flex; gap: 4px; }
    .dot { width: 3px; height: 3px; background: #fff; border-radius: 50%; }
    .user-icon { width: 16px; height: 16px; color: #fff; }
    .user-icon svg { width: 100%; height: 100%; fill: currentColor; }

    /* Menu tray */
    .menu-tray {
      position: fixed; top: 60px; left: 20px; width: 130px;
      background: rgba(0, 0, 0, 1); backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; z-index: 200;
      transform: translateY(-20px); opacity: 0; visibility: hidden; transition: all .3s ease; padding: 10px 0;
    }
    .menu-tray.open { transform: translateY(0); opacity: 1; visibility: visible; }

    .menu-item { position: relative; display: block; width: 100%; padding: 6px 15px; color: #fff; text-decoration: none; font-size: 14px; font-weight: 300; cursor: pointer; background: none; border: 0; }
    .menu-item::before { content: ""; position: absolute; inset: 1px; left: 8px; right: 8px; border-radius: 8px; background: rgba(255,255,255,0.12); opacity: 0; transform: scaleY(0.96); transition: opacity .15s ease, transform .2s ease; pointer-events: none; }
    .menu-item:hover::before, .menu-item:focus-visible::before { opacity: 1; transform: scaleY(1); }
    .menu-item, .menu-item * { position: relative; z-index: 1; }
    .menu-item .menu-pill { background: transparent !important; padding: 0 !important; border-radius: 0 !important; }

    /* Modal */
    .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 300; display: none; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
    .modal-overlay.show { display: flex; }
    .login-modal { background: rgba(0,0,0,0.9); backdrop-filter: blur(20px); border: 1px solid rgba(255,255,255,0.2); border-radius: 16px; padding: 15px; width: 90%; max-width: 400px; position: relative; color: #fff; }
    .modal-close { position: absolute; top: 8px; right: 15px; background: none; border: none; color: rgba(255,255,255,0.6); font-size: 24px; cursor: button; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; transition: all .2s ease; }
    input, textarea, select { font-size: 16px; }
    button, a, .menu-button, .login-button, .chat-toggle, .send-button, .arrow-btn, .character-confirm { touch-action: manipulation; }
    .modal-close:hover { color: #fff; }
    .modal-tabs { display: flex; gap: 20px; margin-bottom: 20px; justify-content: center; }
    .modal-tab { background: none; border: none; color: rgba(255,255,255,0.6); font-size: 16px; padding: 8px 0; cursor: pointer; border-bottom: 2px solid transparent; transition: all .2s ease; }
    .modal-tab.active { color: #fff; }
    .form-group { margin-bottom: 12px; }
    .form-input { width: 100%; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; padding: 12px 15px; color: #fff; font-size: 16px; outline: none; }
    .form-input::placeholder { color: rgba(255,255,255,0.5); }
    .form-button { width: 100%; background: rgba(255,255,255,0.92); color: #000; border: none; border-radius: 8px; padding: 12px; font-size: 14px; font-weight: 500; cursor: pointer; }

    /* Character selector overlay */
    .character-controls { position: fixed; left: 50%; bottom: 8vh; transform: translateX(-50%); z-index: 250; opacity: 0; pointer-events: none; transition: opacity .2s ease; }
    .character-controls.show { opacity: 1; pointer-events: auto; }
    .character-info { display: grid; grid-template-rows: auto auto; gap: 8px; justify-items: center; min-width: 260px; }
    .character-header { display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: 10px; }
    .character-name { text-align: center; font: 600 14px/1 system-ui, Arial, sans-serif; background: none; padding: .35rem .6rem; border-radius: .5rem; min-width: var(--title-width, 200px); }
    .arrow-btn { background: none; border: none; color: #fff; width: 28px; height: 28px; text-align: center; font-size: 18px; line-height: 26px; cursor: pointer; }
    .character-actions { display: flex; justify-content: center; }
    .character-confirm { background: rgba(255,255,255,.92); color: #000; border-radius: 8px; padding: 8px 16px; border: none; cursor: pointer; font-weight: 600; pointer-events: auto;
        z-index: 9999; touch-action: manipulation; }
    

  </style>
</head>
<body>

<div class="container">
  <div id="scene-container"></div>

  <!-- Loading Indicator -->
  <div class="loading-indicator" id="loadingIndicator" style="display: none;">
    <div>Loading Characters...</div>
    <div class="loading-progress">
      <div class="loading-bar" id="loadingBar"></div>
    </div>
    <div id="loadingText">0/3</div>
  </div>

  <!-- Top Navigation -->
  <div class="top-nav">
    <button class="menu-button" onclick="toggleMenu()">
      <div class="menu-dots"><div class="dot"></div><div class="dot"></div><div class="dot"></div></div>
    </button>
    <button class="login-button" onclick="handleLogin()">
      <div class="user-icon">
        <svg viewBox="0 0 24 24"><path d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"/></svg>
      </div>
    </button>
  </div>

  <!-- Menu Tray -->
  <div class="menu-tray" id="menuTray">
    <a href="/landing-page/" class="menu-item"><span class="menu-pill">Home</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Label</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Merch</span></a>
    <a href="/packs/" class="menu-item"><span class="menu-pill">Packs</span></a>
    <a href="#" class="menu-item"><span class="menu-pill">Inventory</span></a>
  </div>

  <!-- Character Selector -->
  <div class="character-controls" id="characterControls">
    <div class="character-info">
      <div class="character-header">
        <button class="arrow-btn" id="prevArrow" title="Previous">‹</button>
        <div class="character-name" id="characterName">Default Character</div>
        <button class="arrow-btn" id="nextArrow" title="Next">›</button>
      </div>
      <div class="character-actions">
        <button class="character-confirm" onclick="window.confirmCharacter()">Select</button>
      </div>
    </div>
  </div>

  <!-- Login Modal -->
  <div class="modal-overlay" id="loginModal">
    <div class="login-modal">
      <button class="modal-close" onclick="closeLoginModal()">&times;</button>
      <div class="modal-tabs">
        <button class="modal-tab active" onclick="switchTab('login')">Account</button>
      </div>
      <div id="loginForm">
        <div class="form-group">
          <input type="email" id="loginEmail" class="form-input" placeholder="Email" required>
        </div>
        <button id="loginSubmit" class="form-button">Create / Login</button>
      </div>
      <div id="signupForm" style="display:none;">
        <div class="form-group"><input type="text" class="form-input" placeholder="Username"></div>
        <div class="form-group"><input type="email" class="form-input" placeholder="Email"></div>
        <button class="form-button">Sign Up</button>
      </div>
    </div>
  </div>
</div>

<script>
  // ===== Globals =====
  let scene, camera, renderer;
  let raycaster, mouseNDC, hoverActive = false, lastHoverState = false, hoverLight = null;
  let gltfLoader, dracoLoader;
  let currentModel = null, currentMixer = null, loadVersion = 0;
  const clock = new THREE.Clock();

  // [CAROUSEL] state
  const carousel = {
    mode: 'view',
    cache: [],
    mixers: [],
    preloadComplete: false
  };

  // expose for other code
  window.scene = null; window.camera = null; window.renderer = null; window.character = null;
  window.currentCharacterIndex = 0;

  function initLoaders() {
    gltfLoader = new THREE.GLTFLoader();
    dracoLoader = new THREE.DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
    gltfLoader.setDRACOLoader(dracoLoader);
  }

  window.characterConfigs = [
    { name: "Sloucho", status: "Unlocked", url: "/assets/models/sloucho.glb", targetHeight: 1.4, y: 0.02, scaleMul: 0.6, trimStart: 1.5, trimEnd: 2.0 },
    { name: "Rás",     status: "Unlocked", url: "/assets/models/ras.glb",     targetHeight: 1.4, y: 0.05, scaleMul: 0.6, trimStart: 0.12, trimEnd: 0.10 },
    { name: "Super Maramu 2000", status: "Unlocked", url: "/assets/models/maramu.glb", targetHeight: 1.4, y: -0.15, scaleMul: 0.5, trimStart: 0.12, trimEnd: 0.10 }
  ];

  // ===== PRELOADING SYSTEM =====
  
  // Show loading indicator
  function showLoading() {
    const indicator = document.getElementById('loadingIndicator');
    if (indicator) {
      indicator.style.display = 'block';
      indicator.style.opacity = '1';
    }
  }

  // Hide loading indicator
  function hideLoading() {
    const indicator = document.getElementById('loadingIndicator');
    if (indicator) {
      indicator.style.opacity = '0';
      setTimeout(() => {
        indicator.style.display = 'none';
      }, 300);
    }
  }

  // Update loading progress
  function updateLoadingProgress(loaded, total) {
    const bar = document.getElementById('loadingBar');
    const text = document.getElementById('loadingText');
    if (bar) {
      const percent = (loaded / total) * 100;
      bar.style.width = percent + '%';
    }
    if (text) {
      text.textContent = `${loaded}/${total}`;
    }
  }

  // Enhanced preload function with progress tracking
  function preloadAllCharacters() {
    if (carousel.preloadComplete) {
      console.log('✅ Characters already preloaded');
      return Promise.resolve();
    }

    const configs = window.characterConfigs || [];
    if (configs.length === 0) return Promise.resolve();

    console.log('🚀 Starting character preload...');
    showLoading();
    updateLoadingProgress(0, configs.length);

    const loadPromises = configs.map((config, index) => {
      return loadCharacterToCache(index).then(() => {
        updateLoadingProgress(index + 1, configs.length);
        console.log(`✅ Preloaded: ${config.name} (index: ${index})`);
      }).catch(err => {
        console.error(`❌ Failed to preload ${config.name}:`, err);
        updateLoadingProgress(index + 1, configs.length);
      });
    });

    return Promise.all(loadPromises).then(() => {
      carousel.preloadComplete = true;
      hideLoading();
      console.log('🎉 All characters preloaded! Cache state:', carousel.cache.length);
      // Debug: log what's in the cache
      carousel.cache.forEach((entry, i) => {
        if (entry) {
          console.log(`Cache[${i}]: ${entry.config.name}, has animations: ${!!entry.originalAnimations}`);
        }
      });
    }).catch(err => {
      console.error('Preloading failed:', err);
      hideLoading();
    });
  }

  // Load a single character into cache
  function loadCharacterToCache(index) {
    const config = window.characterConfigs[index];
    if (!config || carousel.cache[index]) {
      return Promise.resolve(); // Already loaded
    }

    return new Promise((resolve, reject) => {
      gltfLoader.load(
        config.url,
        (gltf) => {
          const root = gltf.scene || gltf.scenes?.[0];
          if (!root) {
            resolve();
            return;
          }

          const targetHeight = config.targetHeight ?? 1.4;

          // Center and scale
          centerAndScaleToHeight(root, targetHeight);
          if (config.scaleMul) root.scale.multiplyScalar(config.scaleMul);

          // Apply Y offset and cache baseY
          root.userData = root.userData || {};
          if (config.y != null && !root.userData.yApplied) {
            root.position.y += config.y;
            root.userData.yApplied = true;
          }
          root.userData.baseY = root.position.y;

          // Setup mesh properties for raycasting and materials
          root.traverse(obj => {
            if (obj.isMesh) {
              obj.castShadow = true;
              obj.receiveShadow = true;
              obj.raycast = THREE.Mesh.prototype.raycast;
              obj.frustumCulled = false;
              
              const storeMaterial = (material) => {
                if (!material) return;
                material.userData = material.userData || {};
                if ('emissive' in material && !material.userData._origEmissive) {
                  material.userData._origEmissive = material.emissive.clone();
                }
              };
              
              if (Array.isArray(obj.material)) {
                obj.material.forEach(storeMaterial);
              } else {
                storeMaterial(obj.material);
              }
            }
          });

          root.updateMatrixWorld(true);

          // Setup animations
          let mixer = null;
          let originalGLTFAnimations = null;
          if (gltf.animations && gltf.animations.length) {
            mixer = new THREE.AnimationMixer(root);
            
            // Store original GLTF animations for cloning later
            originalGLTFAnimations = gltf.animations;
            
            const clips = gltf.animations;
            const baseClip =
              THREE.AnimationClip.findByName(clips, 'Idle') ||
              THREE.AnimationClip.findByName(clips, 'idle') ||
              clips[0];

            const trimStart = Math.max(0, config.trimStart ?? 1.5);
            const trimEnd = Math.max(0, config.trimEnd ?? 2.0);
            const minDur = 0.05;
            const startSec = Math.min(trimStart, Math.max(0, baseClip.duration - minDur));
            const endSec = Math.max(baseClip.duration - trimEnd, startSec + minDur);
            const fps = 30;
            const startFrame = Math.max(0, Math.floor(startSec * fps));
            const endFrame = Math.max(startFrame + 1, Math.ceil(endSec * fps));
            const sub = THREE.AnimationUtils.subclip(
              baseClip, (baseClip.name || 'clip') + '_trim', startFrame, endFrame, fps
            );

            const action = mixer.clipAction(sub);
            action.setLoop(THREE.LoopPingPong, Infinity).reset().setEffectiveWeight(1).play();
            action.time = 1/60;
            mixer.update(0);
          }

          // Keep invisible until needed
          root.visible = false;
          
          // Cache the processed model with original animation data
          carousel.cache[index] = {
            root,
            mixer,
            targetHeight,
            config,
            baseY: root.userData.baseY,
            originalAnimations: originalGLTFAnimations  // Store original animations for cloning
          };

          resolve();
        },
        (progress) => {
          // Optional: You could add individual file progress here
        },
        (error) => {
          console.error(`Failed to load ${config.url}:`, error);
          reject(error);
        }
      );
    });
  }

  // Get character from cache (instant)
  function getCharacterFromCache(index) {
    if (carousel.cache[index]) {
      return carousel.cache[index];
    }
    return null;
  }

  // ===== ENHANCED CHARACTER CREATION =====
  
  window.createCharacter = function() {
    if (!window.scene) {
      console.error('Scene not ready');
      return;
    }

    // Clean up current model properly
    if (currentMixer) {
      try {
        currentMixer.stopAllAction();
        currentMixer.uncacheRoot(currentModel);
      } catch(e) { console.log('Mixer cleanup:', e); }
      currentMixer = null;
    }
    
    if (currentModel) {
      scene.remove(currentModel);
      // Don't dispose if it's from cache - we want to keep the cache intact
      if (!isFromCache(currentModel)) {
        disposeObject(currentModel);
      }
      currentModel = null;
    }

    if (window.character && window.character !== currentModel) {
      try { scene.remove(window.character); } catch {}
      window.character = null;
    }

    const index = window.currentCharacterIndex ?? 0;
    
    // Try to get from cache first
    const cached = getCharacterFromCache(index);
    if (cached && carousel.preloadComplete) {
      console.log(`📦 Loading ${cached.config.name} from cache...`);
      loadFromCache(index, cached);
      return;
    }
    
    // Fallback to direct loading
    console.log(`⏳ Loading ${window.characterConfigs[index]?.name} directly...`);
    loadCharacterDirectly();
  };

  // Helper to check if model is from cache
  function isFromCache(model) {
    return model && model.userData && model.userData.fromCache === true;
  }

  // Load character from cache with proper animation setup
  function loadFromCache(index, cached) {
    const { root, targetHeight, config, originalAnimations } = cached;
    
    // Create a proper clone of the cached model
    const clonedRoot = root.clone();
    clonedRoot.userData.fromCache = true;
    clonedRoot.visible = true;
    
    // Ensure all cloned meshes have proper raycasting setup
    clonedRoot.traverse(obj => {
      if (obj.isMesh) {
        obj.castShadow = true;
        obj.receiveShadow = true;
        obj.raycast = THREE.Mesh.prototype.raycast;
        obj.frustumCulled = false;
      }
    });
    
    // Create fresh animation mixer for the cloned model
    let clonedMixer = null;
    if (originalAnimations && originalAnimations.length > 0) {
      clonedMixer = new THREE.AnimationMixer(clonedRoot);
      
      // Find the base animation clip
      const baseClip = THREE.AnimationClip.findByName(originalAnimations, 'Idle') ||
                       THREE.AnimationClip.findByName(originalAnimations, 'idle') ||
                       originalAnimations[0];
      
      if (baseClip) {
        // Apply trimming settings
        const trimStart = Math.max(0, config.trimStart ?? 1.5);
        const trimEnd = Math.max(0, config.trimEnd ?? 2.0);
        const minDur = 0.05;
        const startSec = Math.min(trimStart, Math.max(0, baseClip.duration - minDur));
        const endSec = Math.max(baseClip.duration - trimEnd, startSec + minDur);
        const fps = 30;
        const startFrame = Math.max(0, Math.floor(startSec * fps));
        const endFrame = Math.max(startFrame + 1, Math.ceil(endSec * fps));
        
        // Create unique trimmed clip
        const trimmedClip = THREE.AnimationUtils.subclip(
          baseClip,
          `${baseClip.name}_trimmed_${index}_${Date.now()}`,
          startFrame, endFrame, fps
        );
        
        // Create and start the action
        const action = clonedMixer.clipAction(trimmedClip);
        action.setLoop(THREE.LoopPingPong, Infinity);
        action.reset();
        action.setEffectiveWeight(1);
        action.play();
        action.time = 1/60; // Small offset for natural start
        clonedMixer.update(0); // Initial update
        
        console.log(`✅ Animation setup complete for ${config.name}`);
      }
    }
    
    // Add to scene and update references
    scene.add(clonedRoot);
    currentModel = clonedRoot;
    currentMixer = clonedMixer;
    window.character = clonedRoot;
    
    // Update camera framing
    frameCameraOnTargetHeight(camera, targetHeight, 1.4, 0.2);
    window.updateCharacterInfo?.();
    
    console.log(`🎭 ${config.name} loaded from cache with animations`);
  }

  // Original character loading method (fallback)
  function loadCharacterDirectly() {
    const list = window.characterConfigs || [];
    const idx = (window.currentCharacterIndex ?? 0) % (list.length || 1);
    const cfg = list[idx];
    if (!cfg || !cfg.url) return;

    const myVersion = ++loadVersion;
    gltfLoader.load(
      cfg.url,
      (gltf) => {
        if (myVersion !== loadVersion) { if (gltf.scene) disposeObject(gltf.scene); return; }
        const root = gltf.scene || gltf.scenes?.[0];
        if (!root) return;

        const targetHeight = cfg.targetHeight ?? 1.8;

        // Center/scale first
        centerAndScaleToHeight(root, targetHeight);
        if (cfg.scaleMul) root.scale.multiplyScalar(cfg.scaleMul);

        // Apply per-character Y offset ONCE and cache the stable baseY
        root.userData = root.userData || {};
        if (cfg.y != null && !root.userData.yApplied) {
          root.position.y += cfg.y;
          root.userData.yApplied = true;
        }
        root.userData.baseY = root.position.y;

        // Make meshes raycast-friendly + cache original emissive
        root.traverse((o) => {
          if (!o.isMesh) return;

          o.castShadow = true;
          o.receiveShadow = true;
          o.raycast = THREE.Mesh.prototype.raycast;
          o.frustumCulled = false;

          const store = (m) => {
            if (!m) return;
            m.userData = m.userData || {};
            if ('emissive' in m && !m.userData._origEmissive) {
              m.userData._origEmissive = m.emissive.clone();
            }
          };
          if (Array.isArray(o.material)) {
            o.material.forEach(store);
          } else {
            store(o.material);
          }
        });

        root.updateMatrixWorld(true);

        // Animations
        if (gltf.animations && gltf.animations.length) {
          currentMixer = new THREE.AnimationMixer(root);
          const clips = gltf.animations;
          const baseClip =
            THREE.AnimationClip.findByName(clips, 'Idle') ||
            THREE.AnimationClip.findByName(clips, 'idle') ||
            clips[0];

          const trimStart = Math.max(0, cfg.trimStart ?? 1.5);
          const trimEnd   = Math.max(0, cfg.trimEnd   ?? 2.0);
          const minDur = 0.05;
          const startSec = Math.min(trimStart, Math.max(0, baseClip.duration - minDur));
          const endSec   = Math.max(baseClip.duration - trimEnd, startSec + minDur);
          const fps = 30;
          const startFrame = Math.max(0, Math.floor(startSec * fps));
          const endFrame   = Math.max(startFrame + 1, Math.ceil(endSec * fps));
          const sub = THREE.AnimationUtils.subclip(
            baseClip,
            (baseClip.name || 'clip') + '_trim',
            startFrame, endFrame, fps
          );

          const action = currentMixer.clipAction(sub);
          action.setLoop(THREE.LoopPingPong, Infinity)
                .reset()
                .setEffectiveWeight(1)
                .play();
          action.time = 1/60;
          currentMixer.update(0);
        } else {
          currentMixer = null;
        }

        root.name = 'CHARACTER';
        scene.add(root);
        currentModel = root;
        window.character = root;

        frameCameraOnTargetHeight(camera, targetHeight, 1.4, 0.2);
        window.updateCharacterInfo?.();
      },
      undefined,
      (err) => console.error('GLB load error for', cfg.url, err)
    );
  }

  function centerAndScaleToHeight(root, targetHeight = 1.8) {
    const box = new THREE.Box3().setFromObject(root);
    const size = new THREE.Vector3(); box.getSize(size);
    const center = new THREE.Vector3(); box.getCenter(center);
    root.position.sub(center);
    root.position.y += targetHeight * 0.5;
    const h = Math.max(size.y, 1e-6);
    const s = targetHeight / h;
    root.scale.multiplyScalar(s);
  }

  function frameCameraOnTargetHeight(camera, targetHeight = 1.8, pad = 1.4, centerYFactor = 0.2) {
    const fovRad = (camera.fov * Math.PI) / 180;
    const halfH  = (targetHeight * pad) / 2;
    const dist   = halfH / Math.tan(fovRad / 2);
    const cy = targetHeight * centerYFactor;
    camera.position.set(0, cy, dist);
    camera.lookAt(0, cy, 0);
    camera.updateProjectionMatrix();
  }

    function tickAnimations() {
      const dt = Math.min(clock.getDelta(), 0.033);
      
      // Update the current character's mixer
      if (currentMixer) {
        try {
          currentMixer.update(dt);
        } catch(e) {
          console.warn('Animation update error:', e);
        }
      }
    }

  // ===== Character UI =====
  window.updateCharacterInfo = function() {
    const config = window.characterConfigs[window.currentCharacterIndex];
    const nameEl = document.getElementById('characterName');
    const confirmBtn = document.querySelector('.character-confirm');
    if (!config || !nameEl) return;
    nameEl.textContent = config.name;
    if (confirmBtn) {
      const locked = config.status === 'Locked';
      confirmBtn.disabled = locked;
      confirmBtn.style.opacity = locked ? '0.5' : '1';
      confirmBtn.textContent = locked ? 'Locked' : 'Select';
    }
  };

  window.previousCharacter = function() {
    console.log('🔄 Switching to previous character');
    window.currentCharacterIndex = (window.currentCharacterIndex - 1 + window.characterConfigs.length) % window.characterConfigs.length;
    console.log(`Now showing index: ${window.currentCharacterIndex} (${window.characterConfigs[window.currentCharacterIndex]?.name})`);
    window.createCharacter?.();
    window.updateCharacterInfo();
  };

  window.nextCharacter = function() {
    console.log('🔄 Switching to next character');
    window.currentCharacterIndex = (window.currentCharacterIndex + 1) % window.characterConfigs.length;
    console.log(`Now showing index: ${window.currentCharacterIndex} (${window.characterConfigs[window.currentCharacterIndex]?.name})`);
    window.createCharacter?.();
    window.updateCharacterInfo();
  };

  window.confirmCharacter = function() {
    const cfg = window.characterConfigs[window.currentCharacterIndex];
    if (!cfg) return;
    if (carousel.mode === 'carousel') {
      if (cfg.status === 'Locked') return;
      exitCarousel(true);
      return;
    }
    if (cfg.status === 'Unlocked') window.hideCharacterControls();
  };

  window.hideCharacterControls = function() {
    document.getElementById('characterControls')?.classList.remove('show');
    lastHoverState = null;
  };

  window.onCharacterClick = function() {
    if (carousel.mode === 'view') enterCarousel();
  };

  function enterCarousel() {
    const c = document.getElementById('characterControls');
    if (c) c.classList.add('show');
    
    const L = scene.userData?.lights, LV = scene.userData?.lightLevels;
    if (L && LV) {
      L.hemi.intensity = LV.hemi * 0.25;
      L.key.intensity = LV.key * 0.35;
      L.fill.intensity = LV.fill * 0.25;
      L.rim.intensity = LV.rim * 0.25;
    }
    
    carousel.mode = 'carousel';
    attachSimpleSwipeInput();
  }

  function exitCarousel(commitSelection) {
    detachSimpleSwipeInput();
    
    const L = scene.userData?.lights, LV = scene.userData?.lightLevels;
    if (L && LV) {
      L.hemi.intensity = LV.hemi;
      L.key.intensity = LV.key;
      L.fill.intensity = LV.fill;
      L.rim.intensity = LV.rim;
    }
    
    carousel.mode = 'view';
    window.hideCharacterControls();
  }

  let simpleSwipe = { active: false, startX: 0, threshold: 50 };

  function attachSimpleSwipeInput() {
    if (simpleSwipe.active) return;
    
    const dom = renderer.domElement;
    simpleSwipe.active = true;
    
    function onStart(e) {
      simpleSwipe.startX = e.touches ? e.touches[0].clientX : e.clientX;
    }
    
    function onEnd(e) {
      const endX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
      const deltaX = endX - simpleSwipe.startX;
      
      if (Math.abs(deltaX) > simpleSwipe.threshold) {
        if (deltaX > 0) {
          window.previousCharacter();
        } else {
          window.nextCharacter();
        }
      }
    }
    
    dom.addEventListener('touchstart', onStart);
    dom.addEventListener('touchend', onEnd);
    dom.addEventListener('mousedown', onStart);
    dom.addEventListener('mouseup', onEnd);
    
    simpleSwipe.handlers = { onStart, onEnd, dom };
  }

  function detachSimpleSwipeInput() {
    if (!simpleSwipe.active || !simpleSwipe.handlers) return;
    
    const { onStart, onEnd, dom } = simpleSwipe.handlers;
    dom.removeEventListener('touchstart', onStart);
    dom.removeEventListener('touchend', onEnd);
    dom.removeEventListener('mousedown', onStart);
    dom.removeEventListener('mouseup', onEnd);
    
    simpleSwipe.active = false;
    simpleSwipe.handlers = null;
  }

  function disposeObject(obj) {
    obj?.traverse?.((node) => {
      if (node.isMesh) {
        node.geometry?.dispose?.();
        const mat = node.material;
        if (Array.isArray(mat)) {
          mat.forEach(m => { m.map?.dispose?.(); m.normalMap?.dispose?.(); m.roughnessMap?.dispose?.(); m.metalnessMap?.dispose?.(); m.emissiveMap?.dispose?.(); m.dispose?.(); });
        } else if (mat) {
          mat.map?.dispose?.(); mat.normalMap?.dispose?.(); mat.roughnessMap?.dispose?.(); mat.metalnessMap?.dispose?.(); mat.emissiveMap?.dispose?.(); mat.dispose?.();
        }
      }
    });
  }

  // ===== Three.js Setup =====
  function initThreeJS() {
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);
    window.scene = scene;

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 5);
    window.camera = camera;
    camera.layers.enable(1);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.1;

    const container = document.getElementById('scene-container');
    container.innerHTML = '';
    container.appendChild(renderer.domElement);

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x1a1a2a, 0.7); scene.add(hemi);
    const key = new THREE.DirectionalLight(0xffffff, 1); key.position.set(5, 8, 6); key.castShadow = true; key.shadow.mapSize.set(2048,2048); key.shadow.camera.near=0.1; key.shadow.camera.far=50; scene.add(key);
    const fill = new THREE.DirectionalLight(0xffffff, 0.5); fill.position.set(-4, 5, 6); scene.add(fill);
    const rim  = new THREE.DirectionalLight(0x88aaff, 0.5); rim.position.set(-5, 2, -6); scene.add(rim);
    
    scene.userData.lights = { hemi, key, fill, rim };
    scene.userData.lightLevels = {
      hemi: hemi.intensity, key: key.intensity, fill: fill.intensity, rim: rim.intensity
    };

    // Raycasting
    raycaster = new THREE.Raycaster();
    mouseNDC = new THREE.Vector2();

    // Events
    renderer.domElement.addEventListener('click', onCanvasClick);
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('mousemove', onMouseMove);

    setFixedTitleWidth("Super Maramu 2000");
  }

  function animate() {
    requestAnimationFrame(animate);
    tickAnimations();
    renderer.render(scene, camera);
  }
  
  let clickPreventUntil = 0;
  
  function onCanvasClick(e) {
    if (performance.now() < clickPreventUntil) return;

    if (carousel && carousel.mode === 'carousel') {
      const cfg = window.characterConfigs?.[window.currentCharacterIndex];
      if (cfg && cfg.status !== 'Locked') exitCarousel(true);
      return;
    }

    const root = currentModel || window.character;
    if (!root || !camera || !renderer) return;

    root.updateMatrixWorld(true);

    const rect = renderer.domElement.getBoundingClientRect();
    const ndc = new THREE.Vector2(
      ((e.clientX - rect.left) / rect.width) * 2 - 1,
      -((e.clientY - rect.top) / rect.height) * 2 + 1
    );

    raycaster.setFromCamera(ndc, camera);

    const hits = raycaster.intersectObject(root, true);
    if (hits.length > 0) {
      window.onCharacterClick();
      return;
    }

    // Fallback: screen-space AABB check
    const box = new THREE.Box3().setFromObject(root);
    if (!box.isEmpty()) {
      const corners = [
        new THREE.Vector3(box.min.x, box.min.y, box.min.z),
        new THREE.Vector3(box.min.x, box.max.y, box.min.z),
        new THREE.Vector3(box.max.x, box.min.y, box.min.z),
        new THREE.Vector3(box.max.x, box.max.y, box.min.z),
        new THREE.Vector3(box.min.x, box.min.y, box.max.z),
        new THREE.Vector3(box.min.x, box.max.y, box.max.z),
        new THREE.Vector3(box.max.x, box.min.y, box.max.z),
        new THREE.Vector3(box.max.x, box.max.y, box.max.z),
      ];
      let minX =  Infinity, minY =  Infinity, maxX = -Infinity, maxY = -Infinity;
      for (const v of corners) {
        v.project(camera);
        const sx = (v.x * 0.5 + 0.5) * rect.width  + rect.left;
        const sy = (-v.y * 0.5 + 0.5) * rect.height + rect.top;
        minX = Math.min(minX, sx); maxX = Math.max(maxX, sx);
        minY = Math.min(minY, sy); maxY = Math.max(maxY, sy);
      }
      if (e.clientX >= minX && e.clientX <= maxX && e.clientY >= minY && e.clientY <= maxY) {
        window.onCharacterClick();
      }
    }
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function onMouseMove(e) {
    mouseNDC.x =  (e.clientX / window.innerWidth)  * 2 - 1;
    mouseNDC.y = -(e.clientY / window.innerHeight) * 2 + 1;
    if (carousel.mode === 'carousel') return;
    checkHover();
  }

  function selectorOpen() {
    return !!document.getElementById('characterControls')?.classList.contains('show');
  }

  function checkHover() {
    if (!window.character) return;
    if (selectorOpen()) {
      if (lastHoverState) { setCharacterHighlight(false); lastHoverState = false; }
      return;
    }
    raycaster.setFromCamera(mouseNDC, camera);
    const intersects = raycaster.intersectObjects(window.character.children, true);
    hoverActive = intersects.length > 0;
    if (hoverActive !== lastHoverState) { setCharacterHighlight(hoverActive); lastHoverState = hoverActive; }
  }

  function setCharacterHighlight(active) {
    if (!window.scene || !window.character) return;
    if (active) {
      if (!hoverLight) {
        hoverLight = new THREE.PointLight(0x88aaff, 0.35, 3, 2);
        hoverLight.castShadow = false;
        hoverLight.position.set(0, 1.2, 1.6);
        window.character.add(hoverLight);
      }
    } else {
      if (hoverLight) { hoverLight.parent?.remove(hoverLight); hoverLight = null; }
      window.character.traverse(obj => {
           if (!obj.isMesh || !obj.material) return;
           const restore = (m) => {
             if (!m) return;
             if ('emissive' in m) {
               const orig = m.userData && m.userData._origEmissive;
               if (orig) m.emissive.copy(orig);
             }
           };
           if (Array.isArray(obj.material)) obj.material.forEach(restore); else restore(obj.material);
         });
    }
  }

  function setFixedTitleWidth(ghostString) {
    const nameEl = document.getElementById('characterName');
    if (!nameEl) return;
    const measurer = document.createElement('span');
    measurer.style.position = 'absolute';
    measurer.style.visibility = 'hidden';
    measurer.style.whiteSpace = 'nowrap';
    measurer.style.fontFamily = getComputedStyle(nameEl).fontFamily;
    measurer.style.fontSize = getComputedStyle(nameEl).fontSize;
    measurer.style.fontWeight = getComputedStyle(nameEl).fontWeight;
    measurer.textContent = ghostString;
    document.body.appendChild(measurer);
    const width = Math.ceil(measurer.getBoundingClientRect().width);
    document.body.removeChild(measurer);
    document.documentElement.style.setProperty('--title-width', width + 'px');
    const info = document.querySelector('.character-info'); if (info) { void getComputedStyle(info).width; }
  }

  // ===== UI bits =====
  function toggleMenu() { document.getElementById('menuTray').classList.toggle('open'); }
  function handleLogin() { document.getElementById('loginModal').classList.add('show'); }
  function closeLoginModal() { document.getElementById('loginModal').classList.remove('show'); }
  function switchTab(tab) {
    const tabs = document.querySelectorAll('.modal-tab');
    const loginForm = document.getElementById('loginForm');
    const signupForm = document.getElementById('signupForm');
    tabs.forEach(t => t.classList.remove('active'));
    if (tab === 'login') { tabs[0].classList.add('active'); loginForm.style.display = 'block'; signupForm.style.display = 'none'; }
    else { tabs[1].classList.add('active'); loginForm.style.display = 'none'; signupForm.style.display = 'block'; }
  }

  document.addEventListener('click', function(e) {
    const tray = document.getElementById('menuTray');
    const btn = document.querySelector('.menu-button');
    if (tray && !tray.contains(e.target) && !btn.contains(e.target)) tray.classList.remove('open');
  });
  document.getElementById('loginModal').addEventListener('click', function(e) { if (e.target === this) closeLoginModal(); });

  // ===== Start =====
  window.addEventListener('load', async () => {
    if (typeof THREE === 'undefined') { console.error('Three.js not loaded'); return; }
    initLoaders();
    initThreeJS();
    
    // Start preloading in background while showing first character
    createCharacter();
    animate();
    
    // Preload all characters after initial load
    setTimeout(() => {
      preloadAllCharacters().then(() => {
        console.log('🚀 All characters ready for instant switching!');
      });
    }, 1000); // Small delay to let initial character load first
    
    document.getElementById('prevArrow')?.addEventListener('click', window.previousCharacter);
    document.getElementById('nextArrow')?.addEventListener('click', window.nextCharacter);
  });

  window.addEventListener('keydown', (e) => {
    if (carousel.mode !== 'carousel') return;
    if (e.key === 'ArrowLeft') window.previousCharacter();
    if (e.key === 'ArrowRight') window.nextCharacter();
  });

  // ===== Mobile zoom suppression =====
  (function () {
    let lastTouchEnd = 0;
    document.addEventListener('touchend', function (e) {
      const now = Date.now();
      if (now - lastTouchEnd <= 300) e.preventDefault();
      lastTouchEnd = now;
    }, { passive: false });
  })();
  document.addEventListener('gesturestart',  e => e.preventDefault(), { passive: false });
  document.addEventListener('gesturechange', e => e.preventDefault(), { passive: false });
  document.addEventListener('gestureend',    e => e.preventDefault(), { passive: false });
  document.addEventListener('touchstart', function (e) { if (e.touches && e.touches.length > 1) e.preventDefault(); }, { passive: false });
  document.addEventListener('touchmove', function (e) { if (typeof e.scale === 'number' && e.scale !== 1) e.preventDefault(); }, { passive: false });

</script>

</body>
</html>
